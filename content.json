{"meta":{"title":"Kaviilee's blog","subtitle":null,"description":"唯有知识不离不弃","author":"kaviilee","url":"https://github.com/Kaviilee/blog.git","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-09-24T14:04:55.105Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"404.html","permalink":"https://github.com/Kaviilee/blog.git/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-09-24T14:04:55.105Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"about/index.html","permalink":"https://github.com/Kaviilee/blog.git/about/index.html","excerpt":"","text":"95后 在职码农 想换份好点的工！ 想回老家种田 _(:зゝ∠) _ 持续更新…"},{"title":"所有分类","date":"2020-09-24T14:04:55.105Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Kaviilee/blog.git/categories/index.html","excerpt":"","text":""},{"title":"essays","date":"2019-09-07T15:08:39.000Z","updated":"2020-09-24T14:04:55.105Z","comments":false,"path":"essays/index.html","permalink":"https://github.com/Kaviilee/blog.git/essays/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-09-24T14:04:55.105Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/Kaviilee/blog.git/friends/index.html","excerpt":"📢 友情链接","text":"📢 友情链接 📢 友链格式 博客名：Kaviilee 地址：https://kaviilee.github.io/blog/ 头像：https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg 简介：唯有知识不离不弃 友链不然分先后顺序 在下方留言板留言，格式如上 申请友链时记得先把本站挂为友链哦~"},{"title":"","date":"2020-09-24T14:04:55.109Z","updated":"2020-09-24T14:04:55.109Z","comments":true,"path":"mylist/index.html","permalink":"https://github.com/Kaviilee/blog.git/mylist/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-09-24T14:04:55.109Z","updated":"2020-09-24T14:04:55.109Z","comments":true,"path":"shuoshuo/index.html","permalink":"https://github.com/Kaviilee/blog.git/shuoshuo/index.html","excerpt":"","text":"new Artitalk({ appId: 'BreaVvx97UMIMsnq4bAaUDuG-MdYXbMMI', appKey: '2F8UD2LPgYvYQM9OOD5X4CJV' }) #pubShuo { margin-right: 4px; } #shanchur, #shuoshuo-modal, #userinfo, #shanchu { padding: 10px 0; } #shuoshuo-modal p { margin: 10px 0; } p.shuoshuo_time span:last-of-type>span { display: flex; }"},{"title":"所有标签","date":"2020-09-24T14:04:55.109Z","updated":"2020-09-24T14:04:55.109Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/Kaviilee/blog.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript类型转换","slug":"javascript类型转换","date":"2020-09-09T23:23:10.000Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"2020/09/09/javascript类型转换/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2020/09/09/javascript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"关于 JavaScript 类型转换的一些笔记。","text":"关于 JavaScript 类型转换的一些笔记。 前言将值从一种类型转换到另一种类型通常称为类型转换。 原始值转布尔值JavaScript中，只有 6 种值可以被转换为false，其余都会被转换成 true。 12345678910console.log(Boolean()) // falseconsole.log(Boolean(false)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(+0)) // falseconsole.log(Boolean(-0)) // falseconsole.log(Boolean(NaN)) // falseconsole.log(Boolean(\"\")) // false 原始值转数字使用 Number 函数将值的类型转换成数字类型。 根据规范，如果有参数，则调用 ToNumber(value) 计算出值返回，否则返回 +0。 此处的 ToNumber 表示的是一个底层规范上实现的方法，并没有暴露出来。 值类型 结果 Undefined NaN Null +0 Boolean 如果是 true，返回1；如果是 false，返回0 Number 返回与之相等的值 String 如下 12345678910111213141516171819202122console.log(Number()) // +0console.log(Number(undefined)) // NaNconsole.log(Number(null)) // +0console.log(Number(false)) // +0console.log(Number(true)) // 1console.log(Number(\"123\")) // 123console.log(Number(\"-123\")) // -123console.log(Number(\"1.2\")) // 1.2console.log(Number(\"000123\")) // 123console.log(Number(\"-000123\")) // -123console.log(Number(\"0x11\")) // 17console.log(Number(\"\")) // 0console.log(Number(\" \")) // 0console.log(Number(\"123 123\")) // NaNconsole.log(Number(\"foo\")) // NaNconsole.log(Number(\"100a\")) // NaN 原始值转字符使用 String 函数将值的类型转换成字符类型。 根据规范，如果函数有参数，则调用 ToString(value) 计算出值返回，否则返回空字符串。 值类型 结果 Undefined ‘undefined’ Null ‘null’ Boolean 如果是 true，返回 “true”；如果是 false，返回 “false” String 返回与之相等的值 Number 如下 1234567891011121314console.log(String()) // 空字符串console.log(String(undefined)) // undefinedconsole.log(String(null)) // nullconsole.log(String(false)) // falseconsole.log(String(true)) // trueconsole.log(String(0)) // 0console.log(String(-0)) // 0console.log(String(NaN)) // NaNconsole.log(String(Infinity)) // Infinityconsole.log(String(-Infinity)) // -Infinityconsole.log(String(1)) // 1 原始值转对象原始值通过调用 String()、Number() 或者 Boolean() 构造函数就能转化为各自的包装对象。 null 和 undefined，当将它们用在期望是一个对象的地方都会造成一个类型错误 (TypeError) 异常，而不会执行正常的转换。 对象转布尔值所有对象转为布尔值都为 true。 对象转字符串和数字对象转换到字符串或者数字都是调用待转换对象的一个方法来实现的。主要有两个方法 toString() 和 valueOf()。 所有对象除了 null 和 undefined 之外的任何值都有 toString 方法，通常，它和 String 方法的返回值是一致的。 JavaScript 根据不同的类各自的特点，定义了更多版本的 toString 方法。 12345678console.log((&#123;&#125;).toString()) // [object Object]console.log([].toString()) // \"\"console.log([0].toString()) // 0console.log([1, 2, 3].toString()) // 1,2,3console.log((function()&#123;var a = 1;&#125;).toString()) // function ()&#123;var a = 1;&#125;console.log((/\\d+/g).toString()) // /\\d+/gconsole.log((new Date(2010, 0, 1)).toString()) // Fri Jan 01 2010 00:00:00 GMT+0800 (CST) 另一个转换对象的方法是 valueOf，表示对象的原始值。默认的 valueOf 方法返回这个对象本身。日期是个例外，它会返回它的一个内容表示：1970 年 1 月 1日以来的毫秒数。 12var date = new Date(2020, 9, 6);console.log(date.valueOf()) // 1601913600000 对象转字符串 值类型 结果 Object 1. primValue = ToPrimitive(input, Number)2. 返回 ToString(primValue)。 对象转数字 参数类型 结果 Object 1. primValue = ToPrimitive(input, Number)2. 返回 ToNumber(primValue)。 12345678910console.log(Number(&#123;&#125;)) // NaNconsole.log(Number(&#123;a : 1&#125;)) // NaNconsole.log(Number([])) // 0console.log(Number([0])) // 0console.log(Number([1, 2, 3])) // NaNconsole.log(Number(function()&#123;var a = 1;&#125;)) // NaNconsole.log(Number(/\\d+/g)) // NaNconsole.log(Number(new Date(2010, 0, 1))) // 1262275200000console.log(Number(new Error('a'))) // NaN Number([]) 时，先调用了 [] 的 valueOf 方法返回了 [] ，因为不是原始值，继续调用 toString 方法，返回空字符串，继续调用 ToNumber，空字符串返回 0。 Number([1,2,3]) 时，先调用了 [1, 2, 3] 的 valueOf 方法返回了 [1, 2, 3]，再调用 toString 方法，返回 1,2,3，调用 ToNumber，返回NaN。 ToPrimitive语法如下： 1ToPrimitive(input[, PreferredType]) 第一个参数是 input，表示要处理的输入值。 第二个参数是 PreferredType，非必填，表示希望转换成的类型，有两个值可以选，Number 或者 String。 当不传入 PreferredType 时，如果 input 是日期类型，相当于传入 String，否则，都相当于传入 Number。 如果传入的 input 是 Undefined、Null、Boolean、Number、String 类型，直接返回该值。 如果是 ToPrimitive(obj, Number)，处理步骤如下： 如果 obj 为 基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 如果是 ToPrimitive(obj, String)，处理步骤如下： 如果 obj为 基本类型，直接返回 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 隐式转换场景 一元操作符 +当 + 运算符作为一元操作符时，会调用 ToNumber 处理该值，相当于 Number(value)。 如果 value 是对象，会先调用 ToPrimitive(obj, Number) 方法。 123console.log(+['1']); // 1console.log(+['1', '2', '3']); // NaNconsole.log(+&#123;&#125;); // NaN 二元操作符 +当计算 value1 + value2 时： lprim = ToPrimitive(value1) rprim = ToPrimitive(value2) 如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim) 的拼接结果 返回 ToNumber(lprim) 和 ToNumber(rprim) 的运算结果 == 相等 类型 (x) 类型 (y) 结果 null undefined true undefined null true 数值 字符串 x == ToNumber(y) 字符串 数值 ToNumber(x) == y 布尔值 任何类型 ToNumber(x) == y 任何类型 布尔值 x = ToNumber(y) 字符串或数 对象 x = ToPrimitive(y) 对象 字符串或数 ToPrimitive(x) == y","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://github.com/Kaviilee/blog.git/categories/javascript/"}],"tags":[]},{"title":"Git Flow","slug":"git-flow","date":"2020-09-03T09:56:17.000Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"2020/09/03/git-flow/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2020/09/03/git-flow/","excerpt":"之前偶尔看到的一篇文章，是讲 Git Flow 的，谈了分支相关的一些知识。","text":"之前偶尔看到的一篇文章，是讲 Git Flow 的，谈了分支相关的一些知识。 Git Flow分支应用场景根据 Git Flow 的建议，主要的分支有 master、develop、hotfix、release 以及 feature 这五种分支，各种分支负责不同的功能。其中 Master 以及 Develop 这两个分支又被称作长期分支，因为他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束而被刪除。 Master 分支主要是用来放稳定、随时可上线的版本。这个分支的来源只能从别的分支合并过来，开发者不会直接 Commit 到这个分支。因为是稳定版本，所以通常也会在这个分支上的 Commit 上打上版本号 tag。 每个版本发布完，develop 会合并到 master，并打tag。 Develop 分支这个分支主要是所有开发的基础分支，当要新增功能的时候，所有的 Feature 分支都是从这个分支切出去的。而 Feature 分支的功能完成后，也都会合并回来这个分支。 开发过程中的稳定分支，develop分支应该保证每次最新的commit都是可以被run的。 Hotfix 分支当线上产品发生紧急问题的时候，会从 Master 分支开一个 Hotfix 分支出来进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。 Release 分支当认为 Develop 分支够成熟了，就可以把 Develop 分支合并到 Release 分支，在这边进行算是上线前的最后测试。测试完成后，Release 分支将会同时合并到 Master 以及 Develop 这两个分支上。 Master 分支是上线版本，而合并回 Develop 分支的目的，是因为可能在 Release 分支上还会测到并修正一些问题，所以需要跟 Develop 分支同步，免得之后的版本又再度出现同样的问题。 其实正常的做法应该是提测，或测试到某个阶段以后使用。一般用在多版本并行开发的时候，充当特定版本的develop 分支使用 Feature 分支当要开始新增功能的时候，就是使用 Feature 分支的时候了。 Feature 分支都是从 Develop 分支来的，完成之后会再并回 Develop 分支。 目前feature分支起名规则以 dev_ 开头，后面跟当前开发功能 分支提交与合并如果 feature 需要 develop 的功能，不要将 develop 分支 merge 到 feature 分支，应该使用 feature rebase develop 分支提交使用 rebase 或 merge 方式都可以，一般来说commit 少的场景我会比较喜欢 rebase，但如果commit攒的多了，rebase 解决冲突会很累。 rebase 操作例如，开始开发时，分支是这样的 123* -- * -- A (develop) \\ * (dev_xxx) 开发完成，准备提交时： 123* -- * -- A -- B -- C -- D -- E (develop) \\ * -- X -- Y -- Z (dev_xxx) 命令行步骤如下（GUI参考命令行执行对应操作） 1234567git add .git commit -m \"xxx\"git pull //用于更新远端分支(git fetch 也可以)git rebase origin/develop //将当前分支base变为develop 的最新 commit 这一步的实际原理是，git会从develop新开一个分支，将你当前的dev_xxx 分支的 commit 按照提交顺序挨个 cherry-pick 到新开分支上 这一步执行过程中如果 develop 的 B C D E等commit 与 X Y Z 冲突，则需要依次解决冲突 解决冲突以后，执行 git rebase --continue 或者 git rebase --skip 继续执行接下来的 rebase rebase 结束后，分支结构将变为： 123* -- * -- A -- B -- C -- D -- E (develop) \\ -- * -- X -- Y -- Z (dev_xxx) 然后需要执行 1git push -f // 必须加 -f 强制推送，否则由于本地分支的base与远端不一致，会报需要 git pull 无法提交 提交完成后去 gitlab 创建 merge request，走正常 review 流程，合并代码。 本文转载自 再聊 Git Flow","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/Kaviilee/blog.git/tags/git/"}]},{"title":"中文文案排版指北","slug":"中文文案排版指北","date":"2020-08-18T11:31:47.000Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"2020/08/18/中文文案排版指北/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2020/08/18/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97/","excerpt":"今天在看文档的时候，偶然看到这篇关于中文文案排版建议的文章，觉得可以分享出来~","text":"今天在看文档的时候，偶然看到这篇关于中文文案排版建议的文章，觉得可以分享出来~ 空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间无需增加空格正确： 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 错误： 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 另外，度／百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue?Microsoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎! 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎! 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这件蛋糕只卖 1000 元。 错误： 这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点正确： 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 本文属于摘录，更多内容在 chinese-copywriting-guidelines ~","categories":[],"tags":[{"name":"文档排版","slug":"文档排版","permalink":"https://github.com/Kaviilee/blog.git/tags/%E6%96%87%E6%A1%A3%E6%8E%92%E7%89%88/"}]},{"title":"Docker 学习笔记","slug":"docker","date":"2020-07-21T00:03:15.000Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"2020/07/21/docker/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2020/07/21/docker/","excerpt":"这是在看完狂神的 Docker 视频之后做的笔记~存档用","text":"这是在看完狂神的 Docker 视频之后做的笔记~存档用 Docker 概述Docekr 为什么会出现一款产品有开发和生产两套环境，也就对应两套应用配置，一般就会存在两个问题。 开发和运维问题：这个项目在我的电脑上是可以运行的！但是伴随版本更新迭代，不同版本环境的兼容，导致服务不可用。 环境配置问题：环境配置是非常麻烦的，每个机器都要部署环境，费时费力。 思考：项目是否可以带上环境一起安装打包？把原始环境一模一样地复制过来？ 在服务器上部署十分麻烦，不能跨平台。 传统开发：开发人员做项目。运维人员做部署 现在：开发打包部署上线，一起做 Docker 能干什么？ 之前的虚拟机技术，所有的项目都在同一个环境下运行。 虚拟机的缺点 1231.占用资源非常多2.冗余技术多3.启动很慢 容器化技术 容器化技术不是一个完整的操作系统 比较 Docker 和虚拟机技术的不同 传统的虚拟机，虚拟出一套硬件后，在其上运行一个完整的操作系统，在该操作系统上安装和运行软件； 容器内的应用直接运行在宿主机的内核，容器是没有自己的内核的，也没有进行硬件虚拟，更加轻便； 每个容器间都是相互隔离的，每个容器都有自己的文件系统，互不影响，能区分计算资源。 DevOps (开发，运维) 更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：一键运行打包镜像发布测试 更便捷的升级和扩缩容 使用了 Docker 之后,我们部署应用就像搭积木一样! 项目打包为一个镜像，扩展，可以在多个服务器上部署。 更简单的系统运维 在容器化之后，我们开发，测试环境是高度一致的。 更高效的计算机资源利用 Docker 是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。 Docker 安装Docker 的基本组成 镜像 (image) Docker 镜像好比一个模板，可以通过这个模板来创建容器服务 nginx 镜像 =&gt; run =&gt; nginx01 (提供服务器)。 通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。 容器 (container) Docker 利用容器技术，独立运行一个或一组应用，通过镜像来创建 容器和镜像关系类似于面向对象编程中的对象和类。 仓库(repository) 仓库就是存放镜像的地方，仓库分为共有仓库和私有仓库。 Docker hub（默认国外镜像），阿里云，网易有国内镜像加速服务。 安装 DockerCentOS Docker 安装 环境准备 会一点 Linux 基础 使用的操作系统 CentOS7 使用 XShell 连接远程服务器 环境查看 123# 查看系统内核# uname -r3.10.0-1062.18.1.el7.x86_64 1234567891011121314151617#系统版本# cat /etc/os-releaseNAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 安装 Docker 12345678910111213141516171819202122232425262728293031# 一, 卸载旧的版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2, 需要安装的包yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2#3. 设置镜像仓库yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #默认是国外的yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #推荐使用#更新yum软件包索引yum makecache fast#安装 docker sudo yum install docker-ce docker-ce-cli containerd.io #启动 dockersystemctl start docker#查看 docker 版本docker version 下载镜像 docker pull [要下载的镜像] 查看下载的镜像 docker images (docker image ls) 卸载 docker 123yum remove docker-ce docker-ce-cli containerd.iorm -rf &#x2F;var&#x2F;lib&#x2F;docker #docker 默认工作路径 Windows Docker 安装（win10）下载官方 Docker-desktop 安装程序 https://www.docker.com/products/docker-desktop 开启 Hyper-V 1234# 开启搜索win + s# 输入启用或关闭windows功能 选中 Hyper-V 配置镜像加速 底层原理Docker 是怎么工作的 Docker 是一个 C/S 结构的系统，Docker 的守护进程运行在主机上，通过 Socket 从客户端访问 DockerServer 接收到 Docker-Client 的指令，就会执行这个命令 Docker 为什么比 VM 快？ Docker 有着比虚拟机更少的抽象层 Dcoker 利用的是宿主机的内核，VM 需要的是 Guest OS 新建一个容器的时候，Docker 不需要像虚拟机一样重新安装一个操作系统内核，虚拟机是加载 Guest OS，分钟级别的，而 Docker 是利用宿主机的操作系统，省略了这个复杂的过程 Docker 命令帮助命令123docker version #docker版本docker info #显示docker的系统信息，包括镜像和容器数量docker [命令] --help #查看某个具体的命令 镜像命令docker images 查看下载的所有镜像 1234567891011121314151617# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.6 8de95e6026c3 20 hours ago 302MBredis latest 36304d3b4540 12 days ago 104MBmysql latest 30f937e841c8 2 weeks ago 541MBcentos/mysql-57-centos7 latest f83a2938370c 8 months ago 452MB# 解释REPOSITORY 镜像的仓库名TAG 镜像的标签IMAGE ID 镜像IDCREATED 镜像创建时间SIZE 镜像的大小#可选项Options: -a, --all #列出所有镜像 -q, --quiet #只显示镜像ID docker search 搜索镜像 123456docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9604 [OK] #可选项,通过收藏来过滤--filter=stars=3000 #搜索出来的镜像收藏就是大于3000的 docker pull 拉取镜像 12345678910111213docker pull nginx [:tag]Using default tag: latest #如果不写tag 默认使用最新版本latest: Pulling from library/nginx8559a31e96f4: Pull complete #分层下载,docker image核心 联合文件系统8d69e59170f7: Pull complete 3f9f1ec1d262: Pull complete d1f5ff4f210d: Pull complete 1e22bfa8652e: Pull complete Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133 #签名Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest #真实地址# docker pull nginx 等价于 dicker pull docker.io/library/nginx:latest docker rmi 删除镜像 123456# 删除指定的镜像$ docker rmi -f 8de95e6026c3 # 删除全部的镜像$ docker rmi -f $(docker images -ap)# 清空临时镜像$ docker rmi $(docker images -q -f dangling=true) docker build 使用dockerfile创建镜像 123# 使用当前目录的 dockerfile 创建镜像 当 dockerfile 的命名为 dockerfile 就不需要制定文件名 -f$ docker build -t node:10.15-alpine .$ docker build -f /path/to/a/dockerfile . # /path/to/a 容器命令新建容器并启动 12345678docker run [options] image# options# 若image本地没有则会去 docker镜像库拉取--name=\"\" 容器名字 用于区分容器-d 后台方式运行-it 使用交互方式运行,进入容器查看内容-p 指定容器的端口 -p 80:8080 主机端口:容器端口-P(大写) 随机指定端口 列出所有运行的容器 12345678910# docker ps 命令 列出当前正在运行的容器# options-a # 列出当前正在运行的容器+历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES919e58ff5521 redis \"Docker-entrypoint.s…\" 20 hours ago Exited (0) 16 hours ago redis 退出容器 1exit #直接容器停止并退出 删除容器 12$ docker rm 容器id$ docker rm -f $(docker ps -aq) #删除所有的容器 启动和停止容器 1234$ docker start 容器id or 容器name # 启动一个或多个已经被停止的容器$ docker restart 容器id or 容器name # 重启容器$ docker stop 容器id or 容器name # 停止运行中的容器$ docker kill 容器id or 容器name # 杀掉运行中的容器 其他常用命令后台启动容器 1$ docker run -d 镜像名 查看容器中进程信息 1$ docker top 容器id 查看镜像元数据 1$ docker inspect 容器id or 容器name 进入当前正在运行的容器 12345678#我们通常容器都是使用后台方式运行的,需要进入容器,修改一些配置#命令# 进入容器后开启一个新的终端,可以在里面操作(常用) 退出 shell 不会导致容器停止运行$ docker exec -it 容器id or name bashshell 默认命令行# 进入容器正在执行的终端,不会启动新的进程 如果退出 shell，容器会停止运行$ docker attach 容器id or 容器name 从容器内拷贝文件到主机上 1$ docker cp 容器id: 容器内路径 目的主机路径 docker system命令 12345# 查看docker磁盘占用情况$ docker system df# 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络$ docker system prune-a # 没有容器使用的 docker 容器都删除 手动清除 docker 镜像/容器/数据卷 1234# 删除所有 dangling 镜像(即无 tag 的镜像)$ docker rmi $(docker images | grep \"^&lt;none&gt;\" | awk \"&#123;print $3&#125;\")# 删除所有 dangling 数据卷(即无用的 volume)$ docker volume rm $(docker volume ls -qf dangling=true) Docker 镜像镜像是什么镜像就是一个轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库，环境变量和配置文件。 如何得到镜像 从远处仓库下载 拷贝 自己制作一个镜像 dockerfile docker 镜像加载原理 UnionFs (联合文件系统查询) 我们下载的时候看到的一层一层就是这个 UnionFs (联合文件系统): Union 文件系统(UnionFS)是一种分层,轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下, Union 文件系统是 Docker 镜像的基础,镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像 特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录结构 Docker 镜像加载原理 Docker 的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS bootfs(boot file system)主要包含 bootlloader 和 kernel, bootfs 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统,在 Docker 镜像的最底层是 bootfs, 这一层与我们典型的 Linux/Unix 系统是一样的,包含 boot 加载器和内核,当 boot 加载完成之后整个内核就在内存中了,此时内存的使用权已由 bootfa 转交给内核,此时系统也会卸载 bootfs rootfs(root file system)，在 bootfs 之上，包含的就是典型 Linux 系统中的 /dev, /proc,/bin, /etc 等标准目录和文件, rootfs 就是各种不同的操作系统发行版,比如 Ubuntu, CentOS 等等 分层理解镜像下载的时候是一层一层的在下载 思考: 为什么 Docker 镜像要采用这种分层的结构呢? 最大好处,我觉得莫过于资源共享了!比如有多个镜像都从相同的 Base 镜像构建而来,那么宿主机 只需在磁盘上保留一份 Base 镜像,同时内存中也只需要加载一份 Base 镜像,这样就可以为所有的容器服务了,而且镜像的每一层都可以被共享 查看镜像分层的方式可以通过 Docker image inspect 命令! commit 镜像1234$ docker commit 提交容器成为一个新的镜像#命令和git原理类似$ docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 目标镜像名:[tag] 容器数据卷什么是容器数据卷Docker 的理念回顾 将应用和环境都打包成一个镜像！ 如果数据都在容器中，那么我们容器删除，数据就会丢失！ 需求: 数据可以持久化 MySQL，容器删了，数据丢失. 需求：MySQL 数据可以存储到本地 容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地 目录的挂载，将容器内的目录挂载到 Linux 上面 总结一句话: 容器的持久化和同步操作! 容器间也可以数据共享的! 使用数据卷 方法一：直接使用命令来挂载 -v 12$ docker run -it -v 主机目录:容器内目录 -p 主机端口:容器端口# 启动起来我们可以使用 docker inspect 容器id 实战:安装 MySQL12345678910111213141516# 获取镜像$ docker pull mysql:5.7# 运行容器,需要做数据挂载! # 安装启动mysql,需要配置密码,这是官方的# 官方测试: docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=密码 -d mysql:tag#启mysql-d 后台运行-p 端口映射-v 端口映射-e 环境配置--name 容器名$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7# 启动成功之后，我们在本地使用navicat来测试连接#navicat-连接到服务器的3310 --- 3310和容器内的3306映射，这个时候我们就可以连接上了 假设我们将容器删除，挂载到本地 的数据卷依旧没有丢失，这就实现了容器数据持久化功能 具名和匿名挂载1234567891011# 匿名挂载-v 容器内路径$ docker run -d -p 8080:80 --name nginx01 -v /etc/nginx nginx:alpine# 查看所有的volume情况$ docker volume lsDRIVER VOLUME NAMElocal b448950f96ca2daed2a90cd21e687431653dc9a2f40ccf51e0ce38432f6564a4# 这个就是匿名挂载，-v时只写了容器内路径，没有写# 通过 -v 卷名:容器内路径 所有的 Docker 容器内的卷,没有指定目录的情况下都是在 /var/lib/Docker/volumes/ 卷名 /_data 我们通过具名挂载可以方便的找到一个卷，大多数情况在使用的具名挂载 123# 如何确定是具名挂载还是匿名挂载还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载 拓展： 12345678#通过 -v 容器内路径: ro rw 改变读写权限# ro read only# read and write#一旦设置了容器权限,容器对挂载出来的内容就有限定了!docker -run -P -name nginx01 -v /etc/nginx:ro nginxdocker -run -P -name nginx01 -v /etc/nginx:rw nginxro : 只要看到ro就说明这个路径只能通过宿主机来改变,容器内部无法操作 dockerfiledockerfile 是用来构建 docker 镜像的文件，命令参数脚本。 构建步骤： 编写一个 dockerfile 文件 docker build 构建成为一个镜像 docker run 镜像 docker push 发布镜像（dockerHub，阿里云镜像仓库） 很多官方镜像都是基础包，很多功能都是没有的，我们通常自己打造自己的镜像 Dockerfile的构建过程基础知识： 每个保留关键字(指令)都必须是大写字母 执行从上到下顺序执行 #表示注释 每一条命令都会创建提交一个镜像层，并提交 Dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 Dockerfile 文件，这个文件十分简单。 Docker 镜像逐渐成为企业交付的标准，必须要掌握 步骤： 开发，部署，运维 Dockerfile：构建文件，定义了一切步骤，源代码 DockerImages：通过 Dockerfile 构建生成的镜像，最终发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务器 Dockerfile的指令123456789101112FROM # 基础镜像, 一切从这里开始构建MANTAINER # 镜像是谁写的, 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤, tomcat镜像,压缩包! 添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 暴露端口配置CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令,触发指令COPY # 类似ADD,将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试docker Hub 中99%镜像都是从 CentOS 基础镜像过来的,然后配置需要的软件 创建一个自己的 CentOS 1234567891011121314151617# 1. 编写 dockerfile 文件FROM centosMAINTAINER jiawei&lt;jiaweilee95@126.com&gt;ENV MYPATH /usr/localWORKDIR $&#123;MYPATH&#125;RUN yum -y install vim &amp;&amp; yum -y install net-toolsEXPOSE 80CMD echo $&#123;MYPATH&#125; &amp;&amp; echo \"--end--\" &amp;&amp; /bin/sh# 2. 通过这个文件构建镜像docker build -f &lt;dockerfile文件目录&gt; -t &lt;镜像名:[tag]&gt; .# 3. 测试 CMD 和 ENTRYPOINT 的区别 12CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令 测试 CMD 12345678910111213141516171819202122232425262728293031323334353637383940# 编写 dockerfile 文件$ vim dockerfile-cmd-testFROM centosCMD [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown.ERRO[0000] error waiting for container: context canceled # cmd的情况下 替换了CMD[\"ls\",\"-a\"]命令,-不是命令追加 ENTRYPOINT 是往命令之后追加 12345678910111213141516171819202122232425262728293031323334353637# 编写dockerfile文件$ vim dockerfile-cmd-testFROM centosENTRYPOINT [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -l# 这里是生效的 实战：Tomcat镜像 准备镜像文件 tomcat 压缩包，jdk 压缩包 编写 Dockerfile 文件，官方命名 Dockerfile，build 会自动寻找这个文件，就不需要 -f 指定文件了 1234567891011121314151617181920212223242526272829FROM centosMAINTAINER czp&lt;2432688105@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.33.tar.gz /usr/local/ADD jdk-8u221-linux-x64.rpm /usr/local/RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.33ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.33# 配置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:/CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.33/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.33/bin/logs/catalina.out 构建镜像 1# docker build -t diytomcat . 本地测试 curl localhost:9090 发布镜像 Dockerhub 地址 hub.docker.com 注册自己的账号! 确定这个账号可以登录 在服务器上提交自己的镜像 1234567891011$ docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 登录完毕就可以提交镜像了,就是一步 docker push 提交到阿里云镜像仓库 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 浏览阿里云 小结 Docker 网络原理理解 Docker0清空所有环境 测试 三个网络 12345678910111213141516# docker 是如何处理容器网络访问的？$ docker run -d -P --name tomcat01 tomcat# 查看容器内部网络地址 ip addr 发现容器启动的时候会得到一个eth0@if8 ip地址，docker分配的$ docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.07: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever# linux能ping通容器内部 原理 我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，我们只要安装了 docker，就会有一个网卡 Docker0 桥接模式，使用的是 veth-pair 技术 再次测试 ip addr 再启动一个容器，发现又多了一对网卡 1234# 我们发现这个容器带来网卡, 都是一对对的# veth-pair 就是一对虚拟机设备接口,他们都是成对出现的,一端连着协议,一端彼此相连# 正因为有这个特性,veth-pair 充当桥梁,连接各种虚拟网络设备的# openStac,Docker容器之间的连接,OVS的连接,都是使用 veth-pair 技术 测试 tomcat01 和 tomcat02 是否能 ping 通 1# 结论：容器和容器之间是可以互相ping通的 结论: tomcat01 和 tomcat02 是共用的一个路由器, Docker0 所有的容器不指定网络的情况下,都是 Docker0 路由的, Docker 会给我们的容器分配一个默认的可用IP 小结 Docker 使用的是 Linux 的桥接，宿主机是一个 Docker 容器的网桥 Docker0 Docker 中所有的网络接口都是虚拟的,虚拟的转发效率高（内网传递文件） 只要容器删除,对应网桥的一对就没了 –link 思考一个场景，我们编写了一个微服务，database url = ip；项目不重启，数据库 ip 改变了，我们希望可以处理这个问题，可以通过名字来访问容器吗？ 1234567891011121314151617181920$ docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link可以解决网络连接问题$ docker run -d -P --name tomcat03 --link tomcat02 tomcat6aedb0ba2e798b184f42f98e4a38ce2a54cb97d47b985d17065b064a7f73d404$ docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.061 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.082 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=5 ttl=64 time=0.039 ms^C--- tomcat02 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 134msrtt min/avg/max/mdev = 0.039/0.052/0.082/0.018 ms# 反向是否可以ping通吗[root@CZP ~]# docker exec -it tomcat02 ping tomcat03 -link 本质就是在 hosts 中添加映射 我们现在玩 docker 已经不建议使用 –link 了! 自定义网络,不使用 Docker0! Docker0 问题: 它不支持容器名连接访问! 自定义网络 查看所有的 Docker 网络 12345$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host localc6fe6b78ab62 none null local 网络模式 bridge: 桥接模式 docker 搭桥（默认） none： 不配置网络 host：和宿主机共享网络 container: 容器内网络连通（用得少，局限很大） 12345678910111213141516# 直接启动的命令 --net brodge,默认docker0docker run -d -P --name tomcat01 --net bridge tomcat# docker0的特点: 默认的,域名是不能访问的, --link可以打通连接# 自定义网络# --driver bridgedocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host local87d0f163b3a0 mynet bridge localc6fe6b78ab62 none null local 自己的网络创建好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105$ Docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123;&#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]$ docker run -d -P --name tomcat-net-01 --net mynet tomcatf8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8$ docker run -d -P --name tomcat-net-02 --net mynet tomcat84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c$ docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123; \"84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c\": &#123; \"Name\": \"tomcat-net-02\", \"EndpointID\": \"889a15d10cf311193a18033af3a75eefa6a074291e84aab65e9d88f4b9889bf2\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" &#125;, \"f8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8\": &#123; \"Name\": \"tomcat-net-01\", \"EndpointID\": \"810c98a4ee532167410f1bc28acbc1d3aac11390e7c5a0c0864c20832bf06fb6\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" &#125; &#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]# 再次测试ping连接$ docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.056 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.156 ms64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.086 ms64 bytes from 192.168.0.3: icmp_seq=4 ttl=64 time=0.037 ms^C--- 192.168.0.3 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 162msrtt min/avg/max/mdev = 0.037/0.083/0.156/0.046 ms# 现在不使用--link也可以ping容器名字$ docker exec -it tomcat-net-02 ping 192.168.0.2PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.039 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.066 ms^C--- 192.168.0.2 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 47msrtt min/avg/max/mdev = 0.039/0.052/0.066/0.015 ms 自定义网络 docker 都帮我们维护好了对应关系，推荐平时这样使用网络！ 好处: 不同的集群使用不同的集群，保证集群之间是安全和健康的 网络连通 1234#测试打通 tomcat01到tomcat-net-01$ docker network connect mynet tomcat01# 连通之后就是将 tomcat01 放到了mynet网络下# 一个容器两个ip 阿里云: 公网ip 私网ip 12345678910111213# 01 连通ok$ docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.087 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.065 ms^C--- tomcat-net-01 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 71msrtt min/avg/max/mdev = 0.065/0.076/0.087/0.011 ms# 02 依旧是连不通的$ docker exec -it tomcat02 ping tomcat-net-01ping: tomcat-net-01: Name or service not known 结论：要跨网络操作别人，就需要使用 docker network connect 连通","categories":[{"name":"技术","slug":"技术","permalink":"https://github.com/Kaviilee/blog.git/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://github.com/Kaviilee/blog.git/tags/docker/"}],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}},{"title":"js获取视口和文档高度","slug":"js获取视口和文档高度","date":"2019-09-07T17:25:18.000Z","updated":"2020-09-24T14:04:55.105Z","comments":true,"path":"2019/09/07/js获取视口和文档高度/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2019/09/07/js%E8%8E%B7%E5%8F%96%E8%A7%86%E5%8F%A3%E5%92%8C%E6%96%87%E6%A1%A3%E9%AB%98%E5%BA%A6/","excerpt":"js获取视口和文档高度","text":"js获取视口和文档高度 js获取视口和文档高度 项目 内容 clientHeight content area + padding offsetHeight border + content area + padding scrollHeight 没有滚动条（内容展开时）的高度 body和html分别表示document.body和document.documentElement html.clientHeight 返回视口高度html.offsetHeight 返回 元素的高度，在没有给 元素设置height时，可以理解为文档高度。ie6-8返回视口高度html.scrollHeight 总是返回文档高度。在 firefox，opera，ie8 中，返回文档高度和视口高度中较大的那个body.clientHeight和body.offsetHeight 返回元素的高度（近似于文档高度），如果 设置 height，则返回设定的值（ie6 仍然返回 内元素的总高度）。body.scrollHeight 总是返回文档高度。在 webkit 中，返回文档高度和视口高度中较大的那个。 总之，获取视口高度用 html.clientHeight ,IE6-8 还可以用 html.offsetHeight。获取文档高度可以用 html.scrollHeight 或 body.scrollHeight。 另外，​​现代浏览器中还有一个属性 window.innerHeight 可以用来获取视口高度，IE9+ 才开始支持。得到的高度有时候会多十几个像素，innerHeight 把滚动条的高度也计算在内。 1234567// 获取视口高度let viewportH = window.innerHeight || document.documentElement.clientHeight;// 获取文档高度let docH = document.body.scrollHeight;// 或者let docH = document.documentElement.scrollHeight","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://github.com/Kaviilee/blog.git/categories/javascript/"}],"tags":[],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}}],"categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://github.com/Kaviilee/blog.git/categories/javascript/"},{"name":"技术","slug":"技术","permalink":"https://github.com/Kaviilee/blog.git/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/Kaviilee/blog.git/tags/git/"},{"name":"文档排版","slug":"文档排版","permalink":"https://github.com/Kaviilee/blog.git/tags/%E6%96%87%E6%A1%A3%E6%8E%92%E7%89%88/"},{"name":"Docker","slug":"docker","permalink":"https://github.com/Kaviilee/blog.git/tags/docker/"}]}
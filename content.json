{"meta":{"title":"Kaviilee's blog","subtitle":null,"description":"唯有知识不离不弃","author":"kaviilee","url":"https://kaviilee.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"404.html","permalink":"https://kaviilee.github.io/blog/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"about/index.html","permalink":"https://kaviilee.github.io/blog/about/index.html","excerpt":"","text":"95后 在职码农 想换份好点的工！ 想回老家种田 _(:зゝ∠) _ 持续更新…"},{"title":"所有分类","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"categories/index.html","permalink":"https://kaviilee.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"essays","date":"2019-09-07T15:08:39.000Z","updated":"2020-12-21T07:17:24.452Z","comments":false,"path":"essays/index.html","permalink":"https://kaviilee.github.io/blog/essays/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"friends/index.html","permalink":"https://kaviilee.github.io/blog/friends/index.html","excerpt":"📢 友情链接","text":"📢 友情链接 📢 友链格式 博客名：Kaviilee 地址：https://kaviilee.github.io/blog/ 头像：https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg 简介：唯有知识不离不弃 友链不然分先后顺序 在下方留言板留言，格式如上 申请友链时记得先把本站挂为友链哦~"},{"title":"","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"mylist/index.html","permalink":"https://kaviilee.github.io/blog/mylist/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"shuoshuo/index.html","permalink":"https://kaviilee.github.io/blog/shuoshuo/index.html","excerpt":"","text":"new Artitalk({ appId: 'BreaVvx97UMIMsnq4bAaUDuG-MdYXbMMI', appKey: '2F8UD2LPgYvYQM9OOD5X4CJV' }) #pubShuo { margin-right: 4px; } #shanchur, #shuoshuo-modal, #userinfo, #shanchu { padding: 10px 0; } #shuoshuo-modal p { margin: 10px 0; } p.shuoshuo_time span:last-of-type>span { display: flex; }"},{"title":"所有标签","date":"2020-12-21T07:17:24.452Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"tags/index.html","permalink":"https://kaviilee.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linear-gradient笔记","slug":"linear-gradient笔记","date":"2020-12-21T15:15:25.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/12/21/linear-gradient笔记/","link":"","permalink":"https://kaviilee.github.io/blog/2020/12/21/linear-gradient%E7%AC%94%E8%AE%B0/","excerpt":"之前用 background-image 的 linear-gradient 画了下划线，觉得很神奇，就去认真学习了一下。做了些小笔记，备忘。","text":"之前用 background-image 的 linear-gradient 画了下划线，觉得很神奇，就去认真学习了一下。做了些小笔记，备忘。 渐变线的构成 CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于 数据类型，是一种特别的 数据类型。 以上是 mdn 关于 linear-gradient 的定义。语法如下 12345678910linear-gradient( [ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop-list&gt; ) \\---------------------------------/ \\----------------------------/ Definition of the gradient line List of color stopswhere &lt;side-or-corner&gt; = [ left | right ] || [ top | bottom ] and &lt;color-stop-list&gt; = [ &lt;linear-color-stop&gt; [, &lt;color-hint&gt;? ]? ]#, &lt;linear-color-stop&gt; and &lt;linear-color-stop&gt; = &lt;color&gt; [ &lt;color-stop-length&gt; ]? and &lt;color-stop-length&gt; = [ &lt;percentage&gt; | &lt;length&gt; ]&#123;1,2&#125; and &lt;color-hint&gt; = [ &lt;percentage&gt; | &lt;length&gt; ] // 颜色中转点 这个函数表示接受第一个参数为是渐变的角度，它可以是单位为 deg，rad，grad 或 turn 的具体的角度值（该角度是顺时针增加的）；还可以是 to 和表示方向的关键词（top，right，bottom，left 这些值会被转换成 0°，90°，180°，270°，其余值会被转换成一个以顶部中央方向为起点顺时针旋转的角度），关键词先后顺序无影响，都是可选的。第二个参数是一系列的颜色节点，由一个 &lt;color&gt; 值组成，并且伴随一个可选的终点位置，这个终点位置可以是一个百分比值或者是沿着渐变轴的 &lt;length&gt;。 渐变容器渐变图像是没有内在尺寸的，是无限大的。那么 linear-gradient 函数的具体尺寸由渐变容器的大小决定。 一般来说，如果给一个元素的 background-image 使用 linear-gradient，那么渐变的区域就是该元素的区域。而如果该元素设置了 background-size 渐变容器就会变成设置的 background-size 大小。 渐变线 渐变线(Gradient line)由包含渐变图形的容器的中心点和一个角度来定义的。 这里借用一下 mdn 的图片 渐变角度linear-gradient 是通过渐变角度来控制渐变的方向的。 如上图所示，红线就是渐变角度。上文中有说到，定义这个角度有两种方法： 使用方向关键词：to &lt;top | right | bottom | left | top right | top left | bottom right | bottom left&gt; 使用具体的角度值：比如 45deg 如果缺省角度值，默认值就是 to bottom (180deg) 这里方向关键词有其对应的具体角度值: top(0deg)，right(90deg)，bottom(180deg)，left(270deg)。 而如果是是使用 to top left 这种复合的顶角关键词，就没有对应的固定角度。因为它依赖的是渐变容器的尺寸，如果容器刚好是一个正方形，那么 to top right 和 45deg 的效果是一样。 渐变色节点 (linear color stop)渐变色节点可以这样定义： 1&lt;linear-color-stop&gt; = &lt;color&gt; [ &lt;percentage&gt; | &lt;length&gt; ]? 这意味着颜色在渐变线上的位置并不需要强制提供。 如果没有提供颜色在渐变线上的位置，颜色的位置就会沿着渐变线平均分布。如果只有 2 个颜色，那么颜色 1 将被放在 0% 的位置，颜色 2 就被放在 100% 的位置；如果有 3 个颜色，那么颜色 1 在 0%，颜色 2 在 50%，颜色 3 在 100%，以此类推。 运用好 linear-gradient 可以让你的页面更好看(是真的","categories":[],"tags":[{"name":"CSS","slug":"css","permalink":"https://kaviilee.github.io/blog/tags/css/"}]},{"title":"使用background-image画虚线","slug":"使用background-image画虚线","date":"2020-12-14T14:54:50.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/12/14/使用background-image画虚线/","link":"","permalink":"https://kaviilee.github.io/blog/2020/12/14/%E4%BD%BF%E7%94%A8background-image%E7%94%BB%E8%99%9A%E7%BA%BF/","excerpt":"在知道可以用 background-image 的渐变来定义虚线之前我都是用 border-bottom: 1px dashed #ccc 的。是新的知识，耶！","text":"在知道可以用 background-image 的渐变来定义虚线之前我都是用 border-bottom: 1px dashed #ccc 的。是新的知识，耶！ 123&lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;background-image&lt;/div&gt;&lt;/div&gt; 传统的 border12345678.container &#123; position: relative; .item &#123; padding: 16px; border-bottom: 1px solid #ccc; &#125;&#125; 使用 border 的效果如下 使用 background-image123456789101112131415161718192021.container &#123; position: relative; .item &#123; padding: 16px; &amp;::after &#123; position: absolute; content: ''; width: 100%; height: 1px; left: 0; bottom: 0; // important background-image: linear-gradient(to right, #ccc 0%, #ccc 50%, transparent 50%); // 设置图片宽度与高度 background-size: 20px 1px; background-repeat: repeat-x; &#125; &#125;&#125; 使用 background-image 就可以通过改变 background-size 来改变虚线的间距。 如果要改变虚线的方向，需要修改 width，height，background-image 和 background-repeat。 123456&amp;::after &#123; width: 1px; height: 100%; background-image: linear-gradient(to bottom, #ccc 0%, #ccc 50%, transparent 50%); background-repeat: repeat-yu;&#125;","categories":[],"tags":[]},{"title":"antd form 自定义校验相关错误问题","slug":"antd-form-自定义校验相关错误问题","date":"2020-12-09T14:17:35.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/12/09/antd-form-自定义校验相关错误问题/","link":"","permalink":"https://kaviilee.github.io/blog/2020/12/09/antd-form-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/","excerpt":"在使用 ant design form 组件自定义校验，进行远程校验数据唯一性的时候，遇到的一些问题以及解决方法。","text":"在使用 ant design form 组件自定义校验，进行远程校验数据唯一性的时候，遇到的一些问题以及解决方法。 问题背景使用 ant design form 设计表单时，某些字段需要进行远程校验，比如：用户名(username)，手机号(mobile)，就需要自定义校验规则。 错误示例在需要进行校验的地方，之前错误的写法 123456789101112131415161718192021222324252627&#x2F;** 验证字段唯一性* @param key 字段key* @param value 字段value*&#x2F;const validateUnique &#x3D; (key: string, value: string): any &#x3D;&gt; &#123; if (value) &#123; remoteValidate(&#123; key, value &#125;).then((res: any) &#x3D;&gt; &#123; if (res.success) &#123; return res.data.isUnique; &#125; &#125;).catch(e &#x3D;&gt; &#123; message.error(e) return false &#125;) &#125;&#125;&lt;Form.Item label&#x3D;&quot;用户名&quot; name&#x3D;&quot;username&quot; required rules&#x3D;&#123;[&#123; required: true, message: &#39;请输入用户名&#39; &#125;, () &#x3D;&gt; (&#123; validator(_, value) &#123; if (!value || validateUnique(&#39;username&#39;, value)) &#123; return Promise.resolve() &#125; return Promise.reject(&#39;已存在相同的用户名&#39;) &#125;&#125;)]&#125;&gt; &lt;Input &#x2F;&gt;&lt;&#x2F;Form.Item&gt; 以上的写法能够校验字段值为空时的错误，但是在进行远程校验字段唯一性的时候，就无法验证。validateUnique 返回的值一直为 undefined，使得错误一直是 已存在相同的用户名。 解决方法为了解决校验一直返回 undefined，我们修改写法为 123456789101112131415161718&lt;Form.Item label&#x3D;&quot;用户名&quot; name&#x3D;&quot;username&quot; required rules&#x3D;&#123;[&#123; required: true, message: &#39;请输入用户名&#39; &#125;, () &#x3D;&gt; (&#123; validator(_, value) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; if (value) &#123; remoteValidate(&#123; key: &#39;username&#39;, value &#125;).then(async (res) &#x3D;&gt; &#123; if (res.data.isUnique) &#123; return resolve() &#125; return reject(&#39;已存在相同的手机号&#39;) &#125;) &#125; else &#123; return reject() &#125; &#125;) &#125;&#125;)]&#125;&gt; &lt;Input &#x2F;&gt;&lt;&#x2F;Form.Item&gt;","categories":[],"tags":[{"name":"Antd v4","slug":"antd-v4","permalink":"https://kaviilee.github.io/blog/tags/antd-v4/"},{"name":"react","slug":"react","permalink":"https://kaviilee.github.io/blog/tags/react/"}]},{"title":"RESTful API 简介与实践","slug":"restful","date":"2020-10-21T17:02:37.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/10/21/restful/","link":"","permalink":"https://kaviilee.github.io/blog/2020/10/21/restful/","excerpt":"RESTful API 相关","text":"RESTful API 相关 REST 全称 Representational State Transfer，即「表现层状态转化」。符合 REST 原则的架构，就被称为 RESTful 架构。 简介一、资源 (Resources)REST 的名称「表现层状态转化」的主语其实是指的是「资源」(Resources)，即 “资源表现层状态转化”。 资源，就是网络上的一个实体，或者说是网络上的一个具体信息。可以是文本，图片，歌曲，服务等等。我们可以用一个 URI 指向它，每种资源对应一个特定的 URI。要获得这个资源，访问这个 URI就可以，因此 URI 也就成了每个资源的地址或者独一无二的标识符。 二、表现层 (Representation)「资源」是一种信息实体，它可以有多种外在表现形式。我们把「资源」具体呈现出来的形式，叫做它的「表现层」(Representation)。 比如，文本可以用 txt 格式表现，也可以用 HTML，XML，JSON等格式表现，图片可以用 JPG 格式表现，也可以用 PNG 格式表现。 URI 只代表资源的实体，不代表表现形式。具体的表现格式，就属于「表现层」的范畴，而URI应该只代表「资源」的位置。它的具体表现形式，应该在HTTP请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对「表现层」的描述。 三、状态转化 (State Transfer)访问一个状态，就代表了客户端和服务端的一个互动过程。在这个过程中，必然涉及到数据和状态的变化。 互联网通讯协议 HTTP 协议，是一个无状态协议。也就是说，所有的状态都保存在服务器端。因此，客户端想要操作服务器，就必须通过某种手段，使服务器发生「状态转化」(State Transfer)。而这种转化是建立在表现层上的，也就是「表现层状态转化」。 在 HTTP 协议中，四个表示操作方式的动词：GET，POST，PUT，DELETE。他们分别对应四种基本操作：GET 获取资源，POST 新建资源(也可以更新资源)，PUT 更新资源，DELETE 删除资源。 四、总结总结一下 RESTful 架构： 每一个 URI 代表一种资源； 客户端和服务器之间，传递这种资源的表现层； 客户端通过四个 HTTP 动词，对服务端资源进行操作，实现「表现层状态转化」。 实践一、URL设计1.1 动词 + 宾语RESTful 的核心思想就是，客户端发出的数据操作指令都是「动词 + 宾语」的结构。比如，GET /todos 这个命令，GET 是动词，/todos 是宾语。 动词通常就是五种 HTTP 方法，对应 CRUD 操作。 GET：读取（Read） POST：新建（Create） PUT：更新（Update） PATCH：更新（Update），通常是部分更新 DELETE：删除（Delete） 1.2 动词的覆盖有些客户端只能使用 GET 和 POST 方法。服务器必须接受 POST 模拟其他三个方法(PUT，PATCH，DELETE) 。 此时，客户端发出的 HTTP 请求，要加上 X-HTTP-Method-Override 属性，告诉服务器应该使用哪个动词来覆盖 POST 方法。 12POST &#x2F;api&#x2F;todos&#x2F;4 HTTP&#x2F;1.1X-HTTP-Method-Override: PUT 1.3 宾语必须是名词宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。 1.4 复数 URL既然 URL 是名词，那么应该使用复数，还是单数？ 这没有统一的规定，但是常见的操作是读取一个集合，比如 GET /articles（读取所有文章），这里明显应该是复数。 为了统一起见，建议都使用复数 URL，比如 GET /articles/2 要好于 GET /article/2。 1.5 避免多级 URL常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。 1GET /authors/12/categories/2 改成查询字符串更好 1GET /authors/12?categories=2 二、状态码2.1 状态码必须精确客户端的每一次请求，服务器都必须给出回应。回应包含 HTTP 状态码和数据两部分。 HTTP 状态码就是一个三位数，分成五个类别。 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 API 不需要 1xx 状态码 2.2 状态码具体意义服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的 HTTP 动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 503 Service Unavailable: 服务器无法处理请求，一般用于网站维护状态 本文摘自阮一峰老师的 理解RESTful架构 和 RESTful API 最佳实践","categories":[{"name":"技术","slug":"技术","permalink":"https://kaviilee.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://kaviilee.github.io/blog/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"约定式提交 (Conventional Commits)","slug":"conventional-commits","date":"2020-10-13T00:19:25.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/10/13/conventional-commits/","link":"","permalink":"https://kaviilee.github.io/blog/2020/10/13/conventional-commits/","excerpt":"关于约定式提交的规范内容。","text":"关于约定式提交的规范内容。 约定式提交 一种用于给提交信息增加人机可读含义的规范。 概述约定式提交规范是一种基于提交消息的轻量级约定。 它提供了一组用于创建清晰的提交历史的简单规则； 这使得编写基于规范的自动化工具变得更容易。在提交信息中描述新特性、bug 修复和破坏性变更。 提交说明的结构如下： 123&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注] 提交说明包含了下面的结构化元素，以向类库使用者表明其意图： fix: 类型为 fix 的提交表示在代码库中修复了一个 bug。 feat: 类型为 feat 的提交表示在代码库中新增了一个功能。 BREAKING CHANGE: 在可选的正文或脚注的起始位置带有 BREAKING CHANGE: 的提交，表示引入了破坏性 API 变更。破坏性变更可以是任意 *类型 *提交的一部分。 其它情况: 除 fix: 和 feat: 之外的提交 类型 也是被允许的，例如 @commitlint/config-conventional（基于 Angular 约定）中推荐的 chore:、docs:、style:、refactor:、perf:、test: 及其他标签。 我们也推荐使用improvement，用于对当前实现进行改进而没有添加新功能或修复错误的提交。 请注意，这些标签在约定式提交规范中并不是强制性的。并且在语义化版本中没有隐式的影响（除非他们包含 BREAKING CHANGE）。 可以为提交类型添加一个围在圆括号内的作用域，以为其提供额外的上下文信息。例如 feat(parser): adds ability to parse arrays.。 示例包含了描述以及正文内有破坏性变更的提交说明123feat: allow provided config object to extend other configsBREAKING CHANGE: &#96;extends&#96; key in config file is now used for extending other config files 不包含正文的提交说明1docs: correct spelling of CHANGELOG 包含作用域的提交说明1feat(lang): add polish language 为 fix 编写的提交说明，包含（可选的） issue 编号12345fix: correct minor typos in codesee the issue for details on the typos fixedcloses issue #12 约定式提交规范 每个提交都必须使用类型字段前缀，它由一个名词组成，诸如 feat 或 fix ，其后接一个可选的作用域字段，以及一个必要的冒号（英文半角）和空格。 当一个提交为应用或类库实现了新特性时，必须使用 feat 类型。 当一个提交为应用修复了 bug 时，必须使用 fix 类型。 作用域字段可以跟随在类型字段后面。作用域必须是一个描述某部分代码的名词，并用圆括号包围，例如： fix(parser): 描述字段必须紧接在类型/作用域前缀的空格之后。描述指的是对代码变更的简短总结，例如： fix: array parsing issue when multiple spaces were contained in string. 在简短描述之后，可以编写更长的提交正文，为代码变更提供额外的上下文信息。正文必须起始于描述字段结束的一个空行后。 在正文结束的一个空行之后，可以编写一行或多行脚注。脚注必须包含关于提交的元信息，例如：关联的合并请求、Reviewer、破坏性变更，每条元信息一行。 破坏性变更必须标示在正文区域最开始处，或脚注区域中某一行的开始。一个破坏性变更必须包含大写的文本 BREAKING CHANGE，后面紧跟冒号和空格。 在 BREAKING CHANGE:之后必须提供描述，以描述对 API 的变更。例如： BREAKING CHANGE: environment variables now take precedence over config files. 在提交说明中，可以使用 feat 和 fix 之外的类型。 工具的实现必须不区分大小写地解析构成约定式提交的信息单元，只有 BREAKING CHANGE 必须是大写的。 可以在类型/作用域前缀之后，: 之前，附加 ! 字符，以进一步提醒注意破坏性变更。当有 ! 前缀时，正文或脚注内必须包含 BREAKING CHANGE: description 具体类型含义如下： 类型 说明 feat: 新增功能 fix: 修复 bug docs: 仅修改文档 style: 样式不会影响代码含义的更改，如 空白符、格式、分号补全、错别字修改等 refactor: 既不修复错误也不增加功能的代码修改 perf: 本次代码的更改可提高性能 test: 添加或修改测试内容 build: 影响构建系统或外部依赖的更改 (Example scopes: webpack, npm) ci: 对 CI 配置文件和脚本的更改 (Example scopes: travis) chore 其他不会修改 src 或测试文件的更改，如 .gitignore,package.json、yarn.json 等 revert 回退旧版本 更多内容参见：约定式提交","categories":[{"name":"技术","slug":"技术","permalink":"https://kaviilee.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kaviilee.github.io/blog/tags/git/"},{"name":"规范","slug":"规范","permalink":"https://kaviilee.github.io/blog/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"JavaScript类型转换","slug":"javascript类型转换","date":"2020-09-09T23:23:10.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/09/09/javascript类型转换/","link":"","permalink":"https://kaviilee.github.io/blog/2020/09/09/javascript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"关于 JavaScript 类型转换的一些笔记。","text":"关于 JavaScript 类型转换的一些笔记。 前言将值从一种类型转换到另一种类型通常称为类型转换。 原始值转布尔值JavaScript中，只有 6 种值可以被转换为false，其余都会被转换成 true。 12345678910console.log(Boolean()) // falseconsole.log(Boolean(false)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(+0)) // falseconsole.log(Boolean(-0)) // falseconsole.log(Boolean(NaN)) // falseconsole.log(Boolean(\"\")) // false 原始值转数字使用 Number 函数将值的类型转换成数字类型。 根据规范，如果有参数，则调用 ToNumber(value) 计算出值返回，否则返回 +0。 此处的 ToNumber 表示的是一个底层规范上实现的方法，并没有暴露出来。 值类型 结果 Undefined NaN Null +0 Boolean 如果是 true，返回1；如果是 false，返回0 Number 返回与之相等的值 String 如下 12345678910111213141516171819202122console.log(Number()) // +0console.log(Number(undefined)) // NaNconsole.log(Number(null)) // +0console.log(Number(false)) // +0console.log(Number(true)) // 1console.log(Number(\"123\")) // 123console.log(Number(\"-123\")) // -123console.log(Number(\"1.2\")) // 1.2console.log(Number(\"000123\")) // 123console.log(Number(\"-000123\")) // -123console.log(Number(\"0x11\")) // 17console.log(Number(\"\")) // 0console.log(Number(\" \")) // 0console.log(Number(\"123 123\")) // NaNconsole.log(Number(\"foo\")) // NaNconsole.log(Number(\"100a\")) // NaN 原始值转字符使用 String 函数将值的类型转换成字符类型。 根据规范，如果函数有参数，则调用 ToString(value) 计算出值返回，否则返回空字符串。 值类型 结果 Undefined ‘undefined’ Null ‘null’ Boolean 如果是 true，返回 “true”；如果是 false，返回 “false” String 返回与之相等的值 Number 如下 1234567891011121314console.log(String()) // 空字符串console.log(String(undefined)) // undefinedconsole.log(String(null)) // nullconsole.log(String(false)) // falseconsole.log(String(true)) // trueconsole.log(String(0)) // 0console.log(String(-0)) // 0console.log(String(NaN)) // NaNconsole.log(String(Infinity)) // Infinityconsole.log(String(-Infinity)) // -Infinityconsole.log(String(1)) // 1 原始值转对象原始值通过调用 String()、Number() 或者 Boolean() 构造函数就能转化为各自的包装对象。 null 和 undefined，当将它们用在期望是一个对象的地方都会造成一个类型错误 (TypeError) 异常，而不会执行正常的转换。 对象转布尔值所有对象转为布尔值都为 true。 对象转字符串和数字对象转换到字符串或者数字都是调用待转换对象的一个方法来实现的。主要有两个方法 toString() 和 valueOf()。 所有对象除了 null 和 undefined 之外的任何值都有 toString 方法，通常，它和 String 方法的返回值是一致的。 JavaScript 根据不同的类各自的特点，定义了更多版本的 toString 方法。 12345678console.log((&#123;&#125;).toString()) // [object Object]console.log([].toString()) // \"\"console.log([0].toString()) // 0console.log([1, 2, 3].toString()) // 1,2,3console.log((function()&#123;var a = 1;&#125;).toString()) // function ()&#123;var a = 1;&#125;console.log((/\\d+/g).toString()) // /\\d+/gconsole.log((new Date(2010, 0, 1)).toString()) // Fri Jan 01 2010 00:00:00 GMT+0800 (CST) 另一个转换对象的方法是 valueOf，表示对象的原始值。默认的 valueOf 方法返回这个对象本身。日期是个例外，它会返回它的一个内容表示：1970 年 1 月 1日以来的毫秒数。 12var date = new Date(2020, 9, 6);console.log(date.valueOf()) // 1601913600000 对象转字符串 值类型 结果 Object 1. primValue = ToPrimitive(input, Number)2. 返回 ToString(primValue)。 对象转数字 参数类型 结果 Object 1. primValue = ToPrimitive(input, Number)2. 返回 ToNumber(primValue)。 12345678910console.log(Number(&#123;&#125;)) // NaNconsole.log(Number(&#123;a : 1&#125;)) // NaNconsole.log(Number([])) // 0console.log(Number([0])) // 0console.log(Number([1, 2, 3])) // NaNconsole.log(Number(function()&#123;var a = 1;&#125;)) // NaNconsole.log(Number(/\\d+/g)) // NaNconsole.log(Number(new Date(2010, 0, 1))) // 1262275200000console.log(Number(new Error('a'))) // NaN Number([]) 时，先调用了 [] 的 valueOf 方法返回了 [] ，因为不是原始值，继续调用 toString 方法，返回空字符串，继续调用 ToNumber，空字符串返回 0。 Number([1,2,3]) 时，先调用了 [1, 2, 3] 的 valueOf 方法返回了 [1, 2, 3]，再调用 toString 方法，返回 1,2,3，调用 ToNumber，返回NaN。 ToPrimitive语法如下： 1ToPrimitive(input[, PreferredType]) 第一个参数是 input，表示要处理的输入值。 第二个参数是 PreferredType，非必填，表示希望转换成的类型，有两个值可以选，Number 或者 String。 当不传入 PreferredType 时，如果 input 是日期类型，相当于传入 String，否则，都相当于传入 Number。 如果传入的 input 是 Undefined、Null、Boolean、Number、String 类型，直接返回该值。 如果是 ToPrimitive(obj, Number)，处理步骤如下： 如果 obj 为 基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 如果是 ToPrimitive(obj, String)，处理步骤如下： 如果 obj为 基本类型，直接返回 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 隐式转换场景 一元操作符 +当 + 运算符作为一元操作符时，会调用 ToNumber 处理该值，相当于 Number(value)。 如果 value 是对象，会先调用 ToPrimitive(obj, Number) 方法。 123console.log(+['1']); // 1console.log(+['1', '2', '3']); // NaNconsole.log(+&#123;&#125;); // NaN 二元操作符 +当计算 value1 + value2 时： lprim = ToPrimitive(value1) rprim = ToPrimitive(value2) 如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim) 的拼接结果 返回 ToNumber(lprim) 和 ToNumber(rprim) 的运算结果 == 相等 类型 (x) 类型 (y) 结果 null undefined true undefined null true 数值 字符串 x == ToNumber(y) 字符串 数值 ToNumber(x) == y 布尔值 任何类型 ToNumber(x) == y 任何类型 布尔值 x = ToNumber(y) 字符串或数 对象 x = ToPrimitive(y) 对象 字符串或数 ToPrimitive(x) == y","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kaviilee.github.io/blog/categories/javascript/"}],"tags":[]},{"title":"Git Flow","slug":"git-flow","date":"2020-09-03T09:56:17.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/09/03/git-flow/","link":"","permalink":"https://kaviilee.github.io/blog/2020/09/03/git-flow/","excerpt":"之前偶尔看到的一篇文章，是讲 Git Flow 的，谈了分支相关的一些知识。","text":"之前偶尔看到的一篇文章，是讲 Git Flow 的，谈了分支相关的一些知识。 Git Flow分支应用场景根据 Git Flow 的建议，主要的分支有 master、develop、hotfix、release 以及 feature 这五种分支，各种分支负责不同的功能。其中 Master 以及 Develop 这两个分支又被称作长期分支，因为他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束而被刪除。 Master 分支主要是用来放稳定、随时可上线的版本。这个分支的来源只能从别的分支合并过来，开发者不会直接 Commit 到这个分支。因为是稳定版本，所以通常也会在这个分支上的 Commit 上打上版本号 tag。 每个版本发布完，develop 会合并到 master，并打tag。 Develop 分支这个分支主要是所有开发的基础分支，当要新增功能的时候，所有的 Feature 分支都是从这个分支切出去的。而 Feature 分支的功能完成后，也都会合并回来这个分支。 开发过程中的稳定分支，develop分支应该保证每次最新的commit都是可以被run的。 Hotfix 分支当线上产品发生紧急问题的时候，会从 Master 分支开一个 Hotfix 分支出来进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。 Release 分支当认为 Develop 分支够成熟了，就可以把 Develop 分支合并到 Release 分支，在这边进行算是上线前的最后测试。测试完成后，Release 分支将会同时合并到 Master 以及 Develop 这两个分支上。 Master 分支是上线版本，而合并回 Develop 分支的目的，是因为可能在 Release 分支上还会测到并修正一些问题，所以需要跟 Develop 分支同步，免得之后的版本又再度出现同样的问题。 其实正常的做法应该是提测，或测试到某个阶段以后使用。一般用在多版本并行开发的时候，充当特定版本的develop 分支使用 Feature 分支当要开始新增功能的时候，就是使用 Feature 分支的时候了。 Feature 分支都是从 Develop 分支来的，完成之后会再并回 Develop 分支。 目前feature分支起名规则以 dev_ 开头，后面跟当前开发功能 分支提交与合并如果 feature 需要 develop 的功能，不要将 develop 分支 merge 到 feature 分支，应该使用 feature rebase develop 分支提交使用 rebase 或 merge 方式都可以，一般来说commit 少的场景我会比较喜欢 rebase，但如果commit攒的多了，rebase 解决冲突会很累。 rebase 操作例如，开始开发时，分支是这样的 123* -- * -- A (develop) \\ * (dev_xxx) 开发完成，准备提交时： 123* -- * -- A -- B -- C -- D -- E (develop) \\ * -- X -- Y -- Z (dev_xxx) 命令行步骤如下（GUI参考命令行执行对应操作） 1234567git add .git commit -m \"xxx\"git pull //用于更新远端分支(git fetch 也可以)git rebase origin/develop //将当前分支base变为develop 的最新 commit 这一步的实际原理是，git会从develop新开一个分支，将你当前的dev_xxx 分支的 commit 按照提交顺序挨个 cherry-pick 到新开分支上 这一步执行过程中如果 develop 的 B C D E等commit 与 X Y Z 冲突，则需要依次解决冲突 解决冲突以后，执行 git rebase --continue 或者 git rebase --skip 继续执行接下来的 rebase rebase 结束后，分支结构将变为： 123* -- * -- A -- B -- C -- D -- E (develop) \\ -- * -- X -- Y -- Z (dev_xxx) 然后需要执行 1git push -f // 必须加 -f 强制推送，否则由于本地分支的base与远端不一致，会报需要 git pull 无法提交 提交完成后去 gitlab 创建 merge request，走正常 review 流程，合并代码。 本文转载自 再聊 Git Flow","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kaviilee.github.io/blog/tags/git/"},{"name":"规范","slug":"规范","permalink":"https://kaviilee.github.io/blog/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"中文文案排版指北","slug":"中文文案排版指北","date":"2020-08-18T11:31:47.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/08/18/中文文案排版指北/","link":"","permalink":"https://kaviilee.github.io/blog/2020/08/18/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97/","excerpt":"今天在看文档的时候，偶然看到这篇关于中文文案排版建议的文章，觉得可以分享出来~","text":"今天在看文档的时候，偶然看到这篇关于中文文案排版建议的文章，觉得可以分享出来~ 空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间无需增加空格正确： 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 错误： 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 另外，度／百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue?Microsoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎! 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎! 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这件蛋糕只卖 1000 元。 错误： 这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点正确： 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 本文属于摘录，更多内容在 chinese-copywriting-guidelines ~","categories":[{"name":"技术","slug":"技术","permalink":"https://kaviilee.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://kaviilee.github.io/blog/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"Docker 学习笔记","slug":"docker","date":"2020-07-21T00:03:15.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2020/07/21/docker/","link":"","permalink":"https://kaviilee.github.io/blog/2020/07/21/docker/","excerpt":"这是在看完狂神的 Docker 视频之后做的笔记~存档用","text":"这是在看完狂神的 Docker 视频之后做的笔记~存档用 Docker 概述Docekr 为什么会出现一款产品有开发和生产两套环境，也就对应两套应用配置，一般就会存在两个问题。 开发和运维问题：这个项目在我的电脑上是可以运行的！但是伴随版本更新迭代，不同版本环境的兼容，导致服务不可用。 环境配置问题：环境配置是非常麻烦的，每个机器都要部署环境，费时费力。 思考：项目是否可以带上环境一起安装打包？把原始环境一模一样地复制过来？ 在服务器上部署十分麻烦，不能跨平台。 传统开发：开发人员做项目。运维人员做部署 现在：开发打包部署上线，一起做 Docker 能干什么？ 之前的虚拟机技术，所有的项目都在同一个环境下运行。 虚拟机的缺点 1231.占用资源非常多2.冗余技术多3.启动很慢 容器化技术 容器化技术不是一个完整的操作系统 比较 Docker 和虚拟机技术的不同 传统的虚拟机，虚拟出一套硬件后，在其上运行一个完整的操作系统，在该操作系统上安装和运行软件； 容器内的应用直接运行在宿主机的内核，容器是没有自己的内核的，也没有进行硬件虚拟，更加轻便； 每个容器间都是相互隔离的，每个容器都有自己的文件系统，互不影响，能区分计算资源。 DevOps (开发，运维) 更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：一键运行打包镜像发布测试 更便捷的升级和扩缩容 使用了 Docker 之后,我们部署应用就像搭积木一样! 项目打包为一个镜像，扩展，可以在多个服务器上部署。 更简单的系统运维 在容器化之后，我们开发，测试环境是高度一致的。 更高效的计算机资源利用 Docker 是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致。 Docker 安装Docker 的基本组成 镜像 (image) Docker 镜像好比一个模板，可以通过这个模板来创建容器服务 nginx 镜像 =&gt; run =&gt; nginx01 (提供服务器)。 通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。 容器 (container) Docker 利用容器技术，独立运行一个或一组应用，通过镜像来创建 容器和镜像关系类似于面向对象编程中的对象和类。 仓库(repository) 仓库就是存放镜像的地方，仓库分为共有仓库和私有仓库。 Docker hub（默认国外镜像），阿里云，网易有国内镜像加速服务。 安装 DockerCentOS Docker 安装 环境准备 会一点 Linux 基础 使用的操作系统 CentOS7 使用 XShell 连接远程服务器 环境查看 123# 查看系统内核# uname -r3.10.0-1062.18.1.el7.x86_64 1234567891011121314151617#系统版本# cat /etc/os-releaseNAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 安装 Docker 12345678910111213141516171819202122232425262728293031# 一, 卸载旧的版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2, 需要安装的包yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2#3. 设置镜像仓库yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #默认是国外的yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #推荐使用#更新yum软件包索引yum makecache fast#安装 docker sudo yum install docker-ce docker-ce-cli containerd.io #启动 dockersystemctl start docker#查看 docker 版本docker version 下载镜像 docker pull [要下载的镜像] 查看下载的镜像 docker images (docker image ls) 卸载 docker 123yum remove docker-ce docker-ce-cli containerd.iorm -rf &#x2F;var&#x2F;lib&#x2F;docker #docker 默认工作路径 Windows Docker 安装（win10）下载官方 Docker-desktop 安装程序 https://www.docker.com/products/docker-desktop 开启 Hyper-V 1234# 开启搜索win + s# 输入启用或关闭windows功能 选中 Hyper-V 配置镜像加速 底层原理Docker 是怎么工作的 Docker 是一个 C/S 结构的系统，Docker 的守护进程运行在主机上，通过 Socket 从客户端访问 DockerServer 接收到 Docker-Client 的指令，就会执行这个命令 Docker 为什么比 VM 快？ Docker 有着比虚拟机更少的抽象层 Dcoker 利用的是宿主机的内核，VM 需要的是 Guest OS 新建一个容器的时候，Docker 不需要像虚拟机一样重新安装一个操作系统内核，虚拟机是加载 Guest OS，分钟级别的，而 Docker 是利用宿主机的操作系统，省略了这个复杂的过程 Docker 命令帮助命令123docker version #docker版本docker info #显示docker的系统信息，包括镜像和容器数量docker [命令] --help #查看某个具体的命令 镜像命令docker images 查看下载的所有镜像 1234567891011121314151617# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.6 8de95e6026c3 20 hours ago 302MBredis latest 36304d3b4540 12 days ago 104MBmysql latest 30f937e841c8 2 weeks ago 541MBcentos/mysql-57-centos7 latest f83a2938370c 8 months ago 452MB# 解释REPOSITORY 镜像的仓库名TAG 镜像的标签IMAGE ID 镜像IDCREATED 镜像创建时间SIZE 镜像的大小#可选项Options: -a, --all #列出所有镜像 -q, --quiet #只显示镜像ID docker search 搜索镜像 123456docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9604 [OK] #可选项,通过收藏来过滤--filter=stars=3000 #搜索出来的镜像收藏就是大于3000的 docker pull 拉取镜像 12345678910111213docker pull nginx [:tag]Using default tag: latest #如果不写tag 默认使用最新版本latest: Pulling from library/nginx8559a31e96f4: Pull complete #分层下载,docker image核心 联合文件系统8d69e59170f7: Pull complete 3f9f1ec1d262: Pull complete d1f5ff4f210d: Pull complete 1e22bfa8652e: Pull complete Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133 #签名Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest #真实地址# docker pull nginx 等价于 dicker pull docker.io/library/nginx:latest docker rmi 删除镜像 123456# 删除指定的镜像$ docker rmi -f 8de95e6026c3 # 删除全部的镜像$ docker rmi -f $(docker images -ap)# 清空临时镜像$ docker rmi $(docker images -q -f dangling=true) docker build 使用dockerfile创建镜像 123# 使用当前目录的 dockerfile 创建镜像 当 dockerfile 的命名为 dockerfile 就不需要制定文件名 -f$ docker build -t node:10.15-alpine .$ docker build -f /path/to/a/dockerfile . # /path/to/a 容器命令新建容器并启动 12345678docker run [options] image# options# 若image本地没有则会去 docker镜像库拉取--name=\"\" 容器名字 用于区分容器-d 后台方式运行-it 使用交互方式运行,进入容器查看内容-p 指定容器的端口 -p 80:8080 主机端口:容器端口-P(大写) 随机指定端口 列出所有运行的容器 12345678910# docker ps 命令 列出当前正在运行的容器# options-a # 列出当前正在运行的容器+历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES919e58ff5521 redis \"Docker-entrypoint.s…\" 20 hours ago Exited (0) 16 hours ago redis 退出容器 1exit #直接容器停止并退出 删除容器 12$ docker rm 容器id$ docker rm -f $(docker ps -aq) #删除所有的容器 启动和停止容器 1234$ docker start 容器id or 容器name # 启动一个或多个已经被停止的容器$ docker restart 容器id or 容器name # 重启容器$ docker stop 容器id or 容器name # 停止运行中的容器$ docker kill 容器id or 容器name # 杀掉运行中的容器 其他常用命令后台启动容器 1$ docker run -d 镜像名 查看容器中进程信息 1$ docker top 容器id 查看镜像元数据 1$ docker inspect 容器id or 容器name 进入当前正在运行的容器 12345678#我们通常容器都是使用后台方式运行的,需要进入容器,修改一些配置#命令# 进入容器后开启一个新的终端,可以在里面操作(常用) 退出 shell 不会导致容器停止运行$ docker exec -it 容器id or name bashshell 默认命令行# 进入容器正在执行的终端,不会启动新的进程 如果退出 shell，容器会停止运行$ docker attach 容器id or 容器name 从容器内拷贝文件到主机上 1$ docker cp 容器id: 容器内路径 目的主机路径 docker system命令 12345# 查看docker磁盘占用情况$ docker system df# 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络$ docker system prune-a # 没有容器使用的 docker 容器都删除 手动清除 docker 镜像/容器/数据卷 1234# 删除所有 dangling 镜像(即无 tag 的镜像)$ docker rmi $(docker images | grep \"^&lt;none&gt;\" | awk \"&#123;print $3&#125;\")# 删除所有 dangling 数据卷(即无用的 volume)$ docker volume rm $(docker volume ls -qf dangling=true) Docker 镜像镜像是什么镜像就是一个轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库，环境变量和配置文件。 如何得到镜像 从远处仓库下载 拷贝 自己制作一个镜像 dockerfile docker 镜像加载原理 UnionFs (联合文件系统查询) 我们下载的时候看到的一层一层就是这个 UnionFs (联合文件系统): Union 文件系统(UnionFS)是一种分层,轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下, Union 文件系统是 Docker 镜像的基础,镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像 特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录结构 Docker 镜像加载原理 Docker 的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS bootfs(boot file system)主要包含 bootlloader 和 kernel, bootfs 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统,在 Docker 镜像的最底层是 bootfs, 这一层与我们典型的 Linux/Unix 系统是一样的,包含 boot 加载器和内核,当 boot 加载完成之后整个内核就在内存中了,此时内存的使用权已由 bootfa 转交给内核,此时系统也会卸载 bootfs rootfs(root file system)，在 bootfs 之上，包含的就是典型 Linux 系统中的 /dev, /proc,/bin, /etc 等标准目录和文件, rootfs 就是各种不同的操作系统发行版,比如 Ubuntu, CentOS 等等 分层理解镜像下载的时候是一层一层的在下载 思考: 为什么 Docker 镜像要采用这种分层的结构呢? 最大好处,我觉得莫过于资源共享了!比如有多个镜像都从相同的 Base 镜像构建而来,那么宿主机 只需在磁盘上保留一份 Base 镜像,同时内存中也只需要加载一份 Base 镜像,这样就可以为所有的容器服务了,而且镜像的每一层都可以被共享 查看镜像分层的方式可以通过 Docker image inspect 命令! commit 镜像1234$ docker commit 提交容器成为一个新的镜像#命令和git原理类似$ docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 目标镜像名:[tag] 容器数据卷什么是容器数据卷Docker 的理念回顾 将应用和环境都打包成一个镜像！ 如果数据都在容器中，那么我们容器删除，数据就会丢失！ 需求: 数据可以持久化 MySQL，容器删了，数据丢失. 需求：MySQL 数据可以存储到本地 容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地 目录的挂载，将容器内的目录挂载到 Linux 上面 总结一句话: 容器的持久化和同步操作! 容器间也可以数据共享的! 使用数据卷 方法一：直接使用命令来挂载 -v 12$ docker run -it -v 主机目录:容器内目录 -p 主机端口:容器端口# 启动起来我们可以使用 docker inspect 容器id 实战:安装 MySQL12345678910111213141516# 获取镜像$ docker pull mysql:5.7# 运行容器,需要做数据挂载! # 安装启动mysql,需要配置密码,这是官方的# 官方测试: docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=密码 -d mysql:tag#启mysql-d 后台运行-p 端口映射-v 端口映射-e 环境配置--name 容器名$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7# 启动成功之后，我们在本地使用navicat来测试连接#navicat-连接到服务器的3310 --- 3310和容器内的3306映射，这个时候我们就可以连接上了 假设我们将容器删除，挂载到本地 的数据卷依旧没有丢失，这就实现了容器数据持久化功能 具名和匿名挂载1234567891011# 匿名挂载-v 容器内路径$ docker run -d -p 8080:80 --name nginx01 -v /etc/nginx nginx:alpine# 查看所有的volume情况$ docker volume lsDRIVER VOLUME NAMElocal b448950f96ca2daed2a90cd21e687431653dc9a2f40ccf51e0ce38432f6564a4# 这个就是匿名挂载，-v时只写了容器内路径，没有写# 通过 -v 卷名:容器内路径 所有的 Docker 容器内的卷,没有指定目录的情况下都是在 /var/lib/Docker/volumes/ 卷名 /_data 我们通过具名挂载可以方便的找到一个卷，大多数情况在使用的具名挂载 123# 如何确定是具名挂载还是匿名挂载还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载 拓展： 12345678#通过 -v 容器内路径: ro rw 改变读写权限# ro read only# read and write#一旦设置了容器权限,容器对挂载出来的内容就有限定了!docker -run -P -name nginx01 -v /etc/nginx:ro nginxdocker -run -P -name nginx01 -v /etc/nginx:rw nginxro : 只要看到ro就说明这个路径只能通过宿主机来改变,容器内部无法操作 dockerfiledockerfile 是用来构建 docker 镜像的文件，命令参数脚本。 构建步骤： 编写一个 dockerfile 文件 docker build 构建成为一个镜像 docker run 镜像 docker push 发布镜像（dockerHub，阿里云镜像仓库） 很多官方镜像都是基础包，很多功能都是没有的，我们通常自己创建自己的镜像。 Dockerfile的构建过程基础知识： 每个保留关键字(指令)都必须是大写字母 执行从上到下顺序执行 #表示注释 每一条命令都会创建提交一个镜像层，并提交 Dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 Dockerfile 文件，这个文件十分简单。 Docker 镜像逐渐成为企业交付的标准，必须要掌握 步骤： 开发，部署，运维 Dockerfile：构建文件，定义了一切步骤，源代码 DockerImages：通过 Dockerfile 构建生成的镜像，最终发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务器 Dockerfile的指令123456789101112FROM # 基础镜像, 一切从这里开始构建MANTAINER # 镜像是谁写的, 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤, tomcat镜像,压缩包! 添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 暴露端口配置CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令,触发指令COPY # 类似ADD,将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试docker Hub 中99%镜像都是从 CentOS 基础镜像过来的,然后配置需要的软件 创建一个自己的 CentOS 1234567891011121314151617# 1. 编写 dockerfile 文件FROM centosMAINTAINER jiawei&lt;jiaweilee95@126.com&gt;ENV MYPATH /usr/localWORKDIR $&#123;MYPATH&#125;RUN yum -y install vim &amp;&amp; yum -y install net-toolsEXPOSE 80CMD echo $&#123;MYPATH&#125; &amp;&amp; echo \"--end--\" &amp;&amp; /bin/sh# 2. 通过这个文件构建镜像docker build -f &lt;dockerfile文件目录&gt; -t &lt;镜像名:[tag]&gt; .# 3. 测试 CMD 和 ENTRYPOINT 的区别 12CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令 测试 CMD 12345678910111213141516171819202122232425262728293031323334353637383940# 编写 dockerfile 文件$ vim dockerfile-cmd-testFROM centosCMD [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown.ERRO[0000] error waiting for container: context canceled # cmd的情况下 替换了CMD[\"ls\",\"-a\"]命令,-不是命令追加 ENTRYPOINT 是往命令之后追加 12345678910111213141516171819202122232425262728293031323334353637# 编写dockerfile文件$ vim dockerfile-cmd-testFROM centosENTRYPOINT [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -l# 这里是生效的 实战：Tomcat镜像 准备镜像文件 tomcat 压缩包，jdk 压缩包 编写 Dockerfile 文件，官方命名 Dockerfile，build 会自动寻找这个文件，就不需要 -f 指定文件了 1234567891011121314151617181920212223242526272829FROM centosMAINTAINER czp&lt;2432688105@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.33.tar.gz /usr/local/ADD jdk-8u221-linux-x64.rpm /usr/local/RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.33ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.33# 配置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:/CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.33/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.33/bin/logs/catalina.out 构建镜像 1# docker build -t diytomcat . 本地测试 curl localhost:9090 发布镜像 Dockerhub 地址 hub.docker.com 注册自己的账号! 确定这个账号可以登录 在服务器上提交自己的镜像 1234567891011$ docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 登录完毕就可以提交镜像了,就是一步 docker push 提交到阿里云镜像仓库 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 浏览阿里云 小结 Docker 网络原理理解 Docker0清空所有环境 测试 三个网络 12345678910111213141516# docker 是如何处理容器网络访问的？$ docker run -d -P --name tomcat01 tomcat# 查看容器内部网络地址 ip addr 发现容器启动的时候会得到一个eth0@if8 ip地址，docker分配的$ docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.07: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever# linux能ping通容器内部 原理 我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，我们只要安装了 docker，就会有一个网卡 Docker0 桥接模式，使用的是 veth-pair 技术 再次测试 ip addr 再启动一个容器，发现又多了一对网卡 1234# 我们发现这个容器带来网卡, 都是一对对的# veth-pair 就是一对虚拟机设备接口,他们都是成对出现的,一端连着协议,一端彼此相连# 正因为有这个特性,veth-pair 充当桥梁,连接各种虚拟网络设备的# openStac,Docker容器之间的连接,OVS的连接,都是使用 veth-pair 技术 测试 tomcat01 和 tomcat02 是否能 ping 通 1# 结论：容器和容器之间是可以互相ping通的 结论: tomcat01 和 tomcat02 是共用的一个路由器, Docker0 所有的容器不指定网络的情况下,都是 Docker0 路由的, Docker 会给我们的容器分配一个默认的可用IP 小结 Docker 使用的是 Linux 的桥接，宿主机是一个 Docker 容器的网桥 Docker0 Docker 中所有的网络接口都是虚拟的,虚拟的转发效率高（内网传递文件） 只要容器删除,对应网桥的一对就没了 –link 思考一个场景，我们编写了一个微服务，database url = ip；项目不重启，数据库 ip 改变了，我们希望可以处理这个问题，可以通过名字来访问容器吗？ 1234567891011121314151617181920$ docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link可以解决网络连接问题$ docker run -d -P --name tomcat03 --link tomcat02 tomcat6aedb0ba2e798b184f42f98e4a38ce2a54cb97d47b985d17065b064a7f73d404$ docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.061 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.082 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=5 ttl=64 time=0.039 ms^C--- tomcat02 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 134msrtt min/avg/max/mdev = 0.039/0.052/0.082/0.018 ms# 反向是否可以ping通吗[root@CZP ~]# docker exec -it tomcat02 ping tomcat03 -link 本质就是在 hosts 中添加映射 我们现在玩 docker 已经不建议使用 –link 了! 自定义网络,不使用 Docker0! Docker0 问题: 它不支持容器名连接访问! 自定义网络 查看所有的 Docker 网络 12345$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host localc6fe6b78ab62 none null local 网络模式 bridge: 桥接模式 docker 搭桥（默认） none： 不配置网络 host：和宿主机共享网络 container: 容器内网络连通（用得少，局限很大） 12345678910111213141516# 直接启动的命令 --net brodge,默认docker0docker run -d -P --name tomcat01 --net bridge tomcat# docker0的特点: 默认的,域名是不能访问的, --link可以打通连接# 自定义网络# --driver bridgedocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host local87d0f163b3a0 mynet bridge localc6fe6b78ab62 none null local 自己的网络创建好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105$ Docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123;&#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]$ docker run -d -P --name tomcat-net-01 --net mynet tomcatf8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8$ docker run -d -P --name tomcat-net-02 --net mynet tomcat84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c$ docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123; \"84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c\": &#123; \"Name\": \"tomcat-net-02\", \"EndpointID\": \"889a15d10cf311193a18033af3a75eefa6a074291e84aab65e9d88f4b9889bf2\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" &#125;, \"f8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8\": &#123; \"Name\": \"tomcat-net-01\", \"EndpointID\": \"810c98a4ee532167410f1bc28acbc1d3aac11390e7c5a0c0864c20832bf06fb6\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" &#125; &#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]# 再次测试ping连接$ docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.056 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.156 ms64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.086 ms64 bytes from 192.168.0.3: icmp_seq=4 ttl=64 time=0.037 ms^C--- 192.168.0.3 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 162msrtt min/avg/max/mdev = 0.037/0.083/0.156/0.046 ms# 现在不使用--link也可以ping容器名字$ docker exec -it tomcat-net-02 ping 192.168.0.2PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.039 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.066 ms^C--- 192.168.0.2 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 47msrtt min/avg/max/mdev = 0.039/0.052/0.066/0.015 ms 自定义网络 docker 都帮我们维护好了对应关系，推荐平时这样使用网络！ 好处: 不同的集群使用不同的集群，保证集群之间是安全和健康的 网络连通 1234#测试打通 tomcat01到tomcat-net-01$ docker network connect mynet tomcat01# 连通之后就是将 tomcat01 放到了mynet网络下# 一个容器两个ip 阿里云: 公网ip 私网ip 12345678910111213# 01 连通ok$ docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.087 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.065 ms^C--- tomcat-net-01 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 71msrtt min/avg/max/mdev = 0.065/0.076/0.087/0.011 ms# 02 依旧是连不通的$ docker exec -it tomcat02 ping tomcat-net-01ping: tomcat-net-01: Name or service not known 结论：要跨网络操作别人，就需要使用 docker network connect 连通","categories":[{"name":"技术","slug":"技术","permalink":"https://kaviilee.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://kaviilee.github.io/blog/tags/docker/"}],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}},{"title":"js获取视口和文档高度","slug":"js获取视口和文档高度","date":"2019-09-07T17:25:18.000Z","updated":"2020-12-21T07:17:24.452Z","comments":true,"path":"2019/09/07/js获取视口和文档高度/","link":"","permalink":"https://kaviilee.github.io/blog/2019/09/07/js%E8%8E%B7%E5%8F%96%E8%A7%86%E5%8F%A3%E5%92%8C%E6%96%87%E6%A1%A3%E9%AB%98%E5%BA%A6/","excerpt":"js获取视口和文档高度","text":"js获取视口和文档高度 js获取视口和文档高度 项目 内容 clientHeight content area + padding offsetHeight border + content area + padding scrollHeight 没有滚动条（内容展开时）的高度 body和html分别表示document.body和document.documentElement html.clientHeight 返回视口高度html.offsetHeight 返回 元素的高度，在没有给 元素设置height时，可以理解为文档高度。ie6-8返回视口高度html.scrollHeight 总是返回文档高度。在 firefox，opera，ie8 中，返回文档高度和视口高度中较大的那个body.clientHeight和body.offsetHeight 返回元素的高度（近似于文档高度），如果 设置 height，则返回设定的值（ie6 仍然返回 内元素的总高度）。body.scrollHeight 总是返回文档高度。在 webkit 中，返回文档高度和视口高度中较大的那个。 总之，获取视口高度用 html.clientHeight ,IE6-8 还可以用 html.offsetHeight。获取文档高度可以用 html.scrollHeight 或 body.scrollHeight。 另外，​​现代浏览器中还有一个属性 window.innerHeight 可以用来获取视口高度，IE9+ 才开始支持。得到的高度有时候会多十几个像素，innerHeight 把滚动条的高度也计算在内。 1234567// 获取视口高度let viewportH = window.innerHeight || document.documentElement.clientHeight;// 获取文档高度let docH = document.body.scrollHeight;// 或者let docH = document.documentElement.scrollHeight","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kaviilee.github.io/blog/categories/javascript/"}],"tags":[],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}}],"categories":[{"name":"技术","slug":"技术","permalink":"https://kaviilee.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"javascript","permalink":"https://kaviilee.github.io/blog/categories/javascript/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://kaviilee.github.io/blog/tags/css/"},{"name":"Antd v4","slug":"antd-v4","permalink":"https://kaviilee.github.io/blog/tags/antd-v4/"},{"name":"react","slug":"react","permalink":"https://kaviilee.github.io/blog/tags/react/"},{"name":"规范","slug":"规范","permalink":"https://kaviilee.github.io/blog/tags/%E8%A7%84%E8%8C%83/"},{"name":"git","slug":"git","permalink":"https://kaviilee.github.io/blog/tags/git/"},{"name":"Docker","slug":"docker","permalink":"https://kaviilee.github.io/blog/tags/docker/"}]}
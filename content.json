{"meta":{"title":"Kaviilee's blog","subtitle":null,"description":"唯有知识不离不弃","author":"kaviilee","url":"https://github.com/Kaviilee/blog.git","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-08-02T11:28:50.766Z","updated":"2020-08-02T11:28:50.766Z","comments":true,"path":"404.html","permalink":"https://github.com/Kaviilee/blog.git/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-08-03T13:04:39.078Z","updated":"2020-08-03T13:04:39.078Z","comments":true,"path":"about/index.html","permalink":"https://github.com/Kaviilee/blog.git/about/index.html","excerpt":"","text":"95后 在职码农 想换份好点的工！ 想回老家种田 _(:зゝ∠) _ 持续更新…"},{"title":"所有分类","date":"2020-08-02T11:28:50.783Z","updated":"2020-08-02T11:28:50.783Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Kaviilee/blog.git/categories/index.html","excerpt":"","text":""},{"title":"essays","date":"2019-09-07T07:08:39.000Z","updated":"2019-09-07T07:09:23.416Z","comments":false,"path":"essays/index.html","permalink":"https://github.com/Kaviilee/blog.git/essays/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-08-03T13:04:39.079Z","updated":"2020-08-03T13:04:39.079Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/Kaviilee/blog.git/friends/index.html","excerpt":"📢 友情链接","text":"📢 友情链接 📢 友链格式 博客名：Kaviilee 地址：https://kaviilee.github.io/blog/ 头像：https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg 简介：唯有知识不离不弃 友链不然分先后顺序 在下方留言板留言，格式如上 申请友链时记得先把本站挂为友链哦~"},{"title":"","date":"2020-08-02T11:28:50.784Z","updated":"2020-08-02T11:28:50.784Z","comments":true,"path":"mylist/index.html","permalink":"https://github.com/Kaviilee/blog.git/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-02T11:28:50.785Z","updated":"2020-08-02T11:28:50.785Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/Kaviilee/blog.git/tags/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-08-02T11:28:50.784Z","updated":"2020-08-02T11:28:50.784Z","comments":true,"path":"shuoshuo/index.html","permalink":"https://github.com/Kaviilee/blog.git/shuoshuo/index.html","excerpt":"","text":""}],"posts":[{"title":"docker学习笔记","slug":"docker","date":"2020-07-20T16:03:15.000Z","updated":"2020-08-03T13:04:39.077Z","comments":true,"path":"2020/07/21/docker/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2020/07/21/docker/","excerpt":"这是在看完狂神的docker视频之后做的笔记~存档用","text":"这是在看完狂神的docker视频之后做的笔记~存档用 Docker概述Docekr为什么会出现一款产品有开发和生产两套环境，两套应用配置 开发和运维问题：这个项目在我的电脑上是可以运行的！版本更新迭代，不同版本环境的兼容，导致服务不可用 环境配置问题：环境配置是非常麻烦的，每个机器都要部署环境，费时费力 思考：项目是否可以带上环境一起安装打包？把原始环境一模一样地复制过来 在服务器上部署十分麻烦，不能跨平台 传统开发：开发人员做项目。运维人员做部署 现在：开发打包部署上线，一起做 Docker能干什么？ 之前的虚拟机技术，所有的项目都在同一个环境下运行 虚拟机的缺点 1231.占用资源非常多2.冗余技术多3.启动很慢 容器化技术 容器化技术不是一个完整的操作系统 比较docker和虚拟机技术的不同 传统的虚拟机，虚拟出一套硬件后，在其上运行一个完整的操作系统，在该操作系统上安装和运行软件 容器内的应用直接运行在宿主机的内核，容器是没有自己的内核的，也没有进行硬件虚拟，更加轻便 每个容器间都是相互隔离的，每个容器都有自己的文件系统，互不影响，能区分计算资源 DevOps(开发，运维) 更快速的交付和部署 传统：一堆帮助文档，安装程序 docker： 一键运行打包镜像发布测试 更便捷的升级和扩缩容 使用了Docker之后,我们部署应用就像搭积木一样! 项目打包为一个镜像,扩展,服务器A!服务器B 更简单的系统运维 在容器化之后，我们开发，测试环境是高度一致的 更高效的计算机资源利用 Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨到极致 Docker安装Docker的基本组成 镜像(image) docker镜像好比一个模板，可以通过这个模板来创建容器服务nginx镜像=&gt; run =&gt; nginx01(提供服务器) 通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的) 容器(container) docker利用容器技术，独立运行一个或一组应用，通过镜像来创建 容器和镜像关系类似于面向对象编程中的对象和类。 启动，停止，删除，基本命令 仓库(repository) 仓库就是存放镜像的地方 仓库分为共有仓库和私有仓库 Docker hub（默认国外镜像）阿里云 网易有国内镜像加速服务 安装DockerCentOS Docker安装 环境准备 会一点Linux基础 CentOS7 使用XShell连接远程服务器 环境查看 123# 查看系统内核# uname -r3.10.0-1062.18.1.el7.x86_64 1234567891011121314151617#系统版本# cat &#x2F;etc&#x2F;os-releaseNAME&#x3D;&quot;CentOS Linux&quot;VERSION&#x3D;&quot;7 (Core)&quot;ID&#x3D;&quot;centos&quot;ID_LIKE&#x3D;&quot;rhel fedora&quot;VERSION_ID&#x3D;&quot;7&quot;PRETTY_NAME&#x3D;&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR&#x3D;&quot;0;31&quot;CPE_NAME&#x3D;&quot;cpe:&#x2F;o:centos:centos:7&quot;HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.centos.org&#x2F;&quot;BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.centos.org&#x2F;&quot;CENTOS_MANTISBT_PROJECT&#x3D;&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION&#x3D;&quot;7&quot;REDHAT_SUPPORT_PRODUCT&#x3D;&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION&#x3D;&quot;7&quot; 安装Docker 12345678910111213141516171819202122232425262728293031# 一, 卸载旧的版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2, 需要安装的包yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2#3. 设置镜像仓库yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo #默认是国外的yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo #推荐使用#更新yum软件包索引yum makecache fast#安装docker sudo yum install docker-ce docker-ce-cli containerd.io #启动dockersystemctl start docker#查看docker版本docker version 下载镜像 docker pull [要下载的镜像] 查看下载的镜像 docker images (docker image ls) 卸载docker 123yum remove docker-ce docker-ce-cli containerd.iorm -rf &#x2F;var&#x2F;lib&#x2F;docker #docker默认工作路径 Windows Docker安装（win10）下载官方docker-desktop安装程序 https://www.docker.com/products/docker-desktop 开启Hyper-V 1234# 开启搜索win + s# 输入启用或关闭windows功能 选中Hyper-V 配置镜像加速 底层原理Docker是怎么工作的 Docker是一个C/S结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问 DockerServer接收到Docker-Client的指令，就会执行这个命令 Docker为什么比VM快 Docker有着比虚拟机更少的抽象层 Dcoker利用的是宿主机的内核，Vm需要的是Guest OS 新建一个容器的时候，Docker不需要像虚拟机一样重新安装一个操作系统内核，虚拟机是加载Guest OS，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程 Docker命令帮助命令123docker version #docker版本docker info #显示docker的系统信息，包括镜像和容器数量docker [命令] --help #查看某个具体的命令 镜像命令docker images 查看下载的所有镜像 1234567891011121314151617# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.6 8de95e6026c3 20 hours ago 302MBredis latest 36304d3b4540 12 days ago 104MBmysql latest 30f937e841c8 2 weeks ago 541MBcentos&#x2F;mysql-57-centos7 latest f83a2938370c 8 months ago 452MB# 解释REPOSITORY 镜像的仓库名TAG 镜像的标签IMAGE ID 镜像IDCREATED 镜像创建时间SIZE 镜像的大小#可选项Options: -a, --all #列出所有镜像 -q, --quiet #只显示镜像ID docker search 搜索镜像 123456docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9604 [OK] #可选项,通过收藏来过滤--filter&#x3D;stars&#x3D;3000 #搜索出来的镜像收藏就是大于3000的 docker pull 拉取镜像 12345678910111213docker pull nginx [:tag]Using default tag: latest #如果不写tag 默认使用最新版本latest: Pulling from library&#x2F;nginx8559a31e96f4: Pull complete #分层下载,docker image核心 联合文件系统8d69e59170f7: Pull complete 3f9f1ec1d262: Pull complete d1f5ff4f210d: Pull complete 1e22bfa8652e: Pull complete Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133 #签名Status: Downloaded newer image for nginx:latestdocker.io&#x2F;library&#x2F;nginx:latest #真实地址# docker pull nginx 等价于 dicker pull docker.io&#x2F;library&#x2F;nginx:latest docker rmi 删除镜像 123456# 删除指定的镜像$ docker rmi -f 8de95e6026c3 # 删除全部的镜像$ docker rmi -f $(docker images -ap)# 清空临时镜像$ docker rmi $(docker images -q -f dangling=true) docker build 使用Dockerfile创建镜像 123# 使用当前目录的Dockerfile创建镜像 当dockerfile的命名为Dockerfile就不需要制定文件名 -f$ docker build -t node:10.15-alpine .$ docker build -f /path/to/a/Dockerfile . # /path/to/a 容器命令新建容器并启动 12345678docker run [options] image# options# 若image本地没有则会去docker镜像库拉取--name=\"\" 容器名字 用于区分容器-d 后台方式运行-it 使用交互方式运行,进入容器查看内容-p 指定容器的端口 -p 80:8080 主机端口:容器端口-P(大写) 随机指定端口 列出所有运行的容器 12345678910# docker ps 命令 列出当前正在运行的容器# options-a # 列出当前正在运行的容器+历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES919e58ff5521 redis \"docker-entrypoint.s…\" 20 hours ago Exited (0) 16 hours ago redis 退出容器 1exit #直接容器停止并退出 删除容器 12$ docker rm 容器id$ docker rm -f $(docker ps -aq) #删除所有的容器 启动和停止容器 1234$ docker start 容器id or 容器name # 启动一个或多个已经被停止的容器$ docker restart 容器id or 容器name # 重启容器$ docker stop 容器id or 容器name # 停止运行中的容器$ docker kill 容器id or 容器name # 杀掉运行中的容器 其他常用命令后台启动容器 1$ docker run -d 镜像名 查看容器中进程信息 1$ docker top 容器id 查看镜像元数据 1$ docker inspect 容器id or 容器name 进入当前正在运行的容器 12345678#我们通常容器都是使用后台方式运行的,需要进入容器,修改一些配置#命令# 进入容器后开启一个新的终端,可以在里面操作(常用) 退出shell不会导致容器停止运行$ docker exec -it 容器id or name bashshell 默认命令行# 进入容器正在执行的终端,不会启动新的进程 如果退出shell，容器会停止运行$ docker attach 容器id or 容器name 从容器内拷贝文件到主机上 1$ docker cp 容器id: 容器内路径 目的主机路径 docker system命令 12345# 查看docker磁盘占用情况$ docker system df# 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络$ docker system prune-a # 没有容器使用的docker容器都删除 手动清除Docker镜像/容器/数据卷 1234# 删除所有dangling镜像(即无tag的镜像)$ docker rmi $(docker images | grep \"^&lt;none&gt;\" | awk \"&#123;print $3&#125;\")# 删除所有 dangling 数据卷(即无用的 volume)$ docker volume rm $(docker volume ls -qf dangling=true) Docker镜像镜像是什么镜像就是一个轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库，环境变量和配置文件。 如何得到镜像 从远处仓库下载 拷贝 自己制作一个镜像Dockerfile Docker镜像加载原理 UnionFs(联合文件系统查询) 我们下载的时候看到的一层一层就是这个 UnionFs(联合文件系统): Union文件系统(UnionFS)是一种分层,轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下,Union文件系统是Docker镜像的基础,镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像 特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录结构 Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS bootfs(boot file system)主要包含bootlloader和kernel,bootfs主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统,在docker镜像的最底层是bootfs,这一层与我们典型的Linux/Unix系统是一样的,包含boot加载器和内核,当boot加载完成之后整个内核就在内存中了,此时内存的使用权已由bootfa转交给内核,此时系统也会卸载bootfs rootfs(root file system),在bootfs之上,包含的就是典型Linux系统中的/dev, /proc,/bin, /etc等标准目录和文件,rootfs就是各种不同的操作系统发行版,比如Ubuntu, CentOS等等 分层理解镜像下载的时候是一层一层的在下载 思考: 为什么Docker镜像要采用这种分层的结构呢? 最大好处,我觉得莫过于资源共享了!比如有多个镜像都从相同的Base镜像构建而来,那么宿主机 只需在磁盘上保留一份base镜像,同时内存中也只需要加载一份base镜像,这样就可以为所有的容器服务了,而且镜像的每一层都可以被共享 查看镜像分层的方式可以通过 docker image inspect 命令! commit镜像1234$ docker commit 提交容器成为一个新的镜像#命令和git原理类似$ docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 目标镜像名:[tag] 容器数据卷什么是容器数据卷docker的理念回顾 将应用和环境都打包成一个镜像！ 如果数据都在容器中，那么我们容器删除，数据就会丢失！ 需求: 数据可以持久化 mysql，容器删了，数据丢失. 需求：mysql数据可以存储到本地 容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地 目录的挂载,将容器内的目录挂载到Linux上面 总结一句话: 容器的持久化和同步操作! 容器间也可以数据共享的! 使用数据卷 方法一：直接使用命令来挂载 -v 12$ docker run -it -v 主机目录:容器内目录 -p 主机端口:容器端口# 启动起来我们可以使用 docker inspect 容器id 实战:安装MySQL12345678910111213141516# 获取镜像$ docker pull mysql:5.7# 运行容器,需要做数据挂载! # 安装启动mysql,需要配置密码,这是官方的# 官方测试: docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=密码 -d mysql:tag#启mysql-d 后台运行-p 端口映射-v 端口映射-e 环境配置--name 容器名$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7# 启动成功之后，我们在本地使用navicat来测试连接#navicat-连接到服务器的3310 --- 3310和容器内的3306映射，这个时候我们就可以连接上了 假设我们将容器删除，挂载到本地 的数据卷依旧没有丢失，这就实现了容器数据持久化功能 具名和匿名挂载1234567891011# 匿名挂载-v 容器内路径$ docker run -d -p 8080:80 --name nginx01 -v /etc/nginx nginx:alpine# 查看所有的volume情况$ docker volume lsDRIVER VOLUME NAMElocal b448950f96ca2daed2a90cd21e687431653dc9a2f40ccf51e0ce38432f6564a4# 这个就是匿名挂载，-v时只写了容器内路径，没有写# 通过 -v 卷名:容器内路径 所有的docker容器内的卷,没有指定目录的情况下都是在/var/lib/docker/volumes/卷名/_data 我们通过具名挂载可以方便的找到一个卷,大多数情况在使用的具名挂载 123# 如何确定是具名挂载还是匿名挂载还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载 拓展： 12345678#通过 -v 容器内路径: ro rw 改变读写权限# ro read only# read and write#一旦设置了容器权限,容器对挂载出来的内容就有限定了!docker -run -P -name nginx01 -v /etc/nginx:ro nginxdocker -run -P -name nginx01 -v /etc/nginx:rw nginxro : 只要看到ro就说明这个路径只能通过宿主机来改变,容器内部无法操作 Dockerfiledockerfile是用来构建docker镜像的文件，命令参数脚本！ 构建步骤： 编写一个dockerfile文件 docker build构建成为一个镜像 docker run镜像 docker push发布镜像（DockerHub，阿里云镜像仓库） 很多官方镜像都是基础包，很多功能都是没有的，我们通常自己打剑自己的镜像 Dockerfile的构建过程基础知识： 每个保留关键字(指令)都必须是大写字母 执行从上到下顺序执行 #表示注释 每一条命令都会创建提交一个镜像层，并提交 dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业交付的标准，必须要掌握 步骤： 开发，部署，运维 Dockerfile：构建文件，定义了一切步骤，源代码 DockerImages：通过Dockerfile构建生成的镜像，最终发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务器 Dockerfile的指令123456789101112FROM # 基础镜像, 一切从这里开始构建MANTAINER # 镜像是谁写的, 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤, tomcat镜像,压缩包! 添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 暴露端口配置CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令,触发指令COPY # 类似ADD,将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试Docker Hub 中99%镜像都是从centos基础镜像过来的,然后配置需要的软件 创建一个自己的centos 1234567891011121314151617# 1. 编写dockerfile文件FROM centosMAINTAINER jiawei&lt;jiaweilee95@126.com&gt;ENV MYPATH /usr/localWORKDIR $&#123;MYPATH&#125;RUN yum -y install vim &amp;&amp; yum -y install net-toolsEXPOSE 80CMD echo $&#123;MYPATH&#125; &amp;&amp; echo \"--end--\" &amp;&amp; /bin/sh# 2. 通过这个文件构建镜像docker build -f &lt;dockerfile文件目录&gt; -t &lt;镜像名:[tag]&gt; .# 3. 测试 对比原生centos： 增加之后的镜像： CMD和ENTRYPOINT的区别 12CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令 测试CMD 12345678910111213141516171819202122232425262728293031323334353637383940# 编写dockerfile文件$ vim dockerfile-cmd-testFROM centosCMD [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown.ERRO[0000] error waiting for container: context canceled # cmd的情况下 替换了CMD[\"ls\",\"-a\"]命令,-不是命令追加 ENTRYPOINT是往命令之后追加 12345678910111213141516171819202122232425262728293031323334353637# 编写dockerfile文件$ vim dockerfile-cmd-testFROM centosENTRYPOINT [\"ls\", \"-a\"]# 构建镜像$ docker build -f dockerfile-cmd-test -t centos .# run 运行，发现ls -a生效$ docker run 963149b1ac5d....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想要追加一个命令 -l ls -al$ docker run 963149b1ac5d -l# 这里是生效的 实战：Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 编写Dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定文件了 1234567891011121314151617181920212223242526272829FROM centosMAINTAINER czp&lt;2432688105@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.33.tar.gz /usr/local/ADD jdk-8u221-linux-x64.rpm /usr/local/RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.33ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.33# 配置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:/CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.33/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.33/bin/logs/catalina.out 构建镜像 1# docker build -t diytomcat . 本地测试 curl localhost:9090 发布镜像 Dokcerhub 地址hub.docker.com 注册自己的账号! 确定这个账号可以登录 在服务器上提交自己的镜像 1234567891011$ docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 登录完毕就可以提交镜像了,就是一步 docker push 提交到阿里云镜像仓库 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 浏览阿里云 小结 Docker网络原理理解Docker0清空所有环境 测试 三个网络 12345678910111213141516# docker是如何处理容器网络访问的？$ docker run -d -P --name tomcat01 tomcat# 查看容器内部网络地址 ip addr 发现容器启动的时候会得到一个eth0@if8 ip地址，docker分配的$ docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.07: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever# linux能ping通容器内部 原理 我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0 桥接模式，使用的是veth-pair技术 再次测试 ip addr 再启动一个容器，发现又多了一对网卡 1234# 我们发现这个容器带来网卡, 都是一对对的# veth-pair 就是一对虚拟机设备接口,他们都是成对出现的,一端连着协议,一端彼此相连# 正因为有这个特性,veth-pair 充当桥梁,连接各种虚拟网络设备的# openStac,Docker容器之间的连接,OVS的连接,都是使用 veth-pair 技术 测试tomcat01 和tomcat02是否能ping通 1# 结论：容器和容器之间是可以互相ping通的 结论: tomcat01和tomcat02是共用的一个路由器,docker0 所有的容器不指定网络的情况下,都是docker0路由的,docker会给我们的容器分配一个默认的可用IP 小结 Docker使用的是linux的桥接，宿主机是一个Docker容器的网桥 Docker0 Docker中所有的网络接口都是虚拟的,虚拟的转发效率高（内网传递文件） 只要容器删除,对应网桥的一对就没了 –link 思考一个场景，我们编写了一个微服务，database url = ip；项目不重启，数据库ip改变了，我们希望可以处理这个问题，可以通过名字来访问容器吗？ 1234567891011121314151617181920$ docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link可以解决网络连接问题$ docker run -d -P --name tomcat03 --link tomcat02 tomcat6aedb0ba2e798b184f42f98e4a38ce2a54cb97d47b985d17065b064a7f73d404$ docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.061 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.040 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.082 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=5 ttl=64 time=0.039 ms^C--- tomcat02 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 134msrtt min/avg/max/mdev = 0.039/0.052/0.082/0.018 ms# 反向是否可以ping通吗[root@CZP ~]# docker exec -it tomcat02 ping tomcat03 -link 本质就是在hosts中添加映射 我们现在玩Docker已经不建议使用–link了! 自定义网络,不使用docker0! docker0问题: 它不支持容器名连接访问! 自定义网络 查看所有的docker网络 12345$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host localc6fe6b78ab62 none null local 网络模式 bridge: 桥接模式 docker 搭桥（默认） none： 不配置网络 host：和宿主机共享网络 container: 容器内网络连通（用得少，局限很大） 12345678910111213141516# 直接启动的命令 --net brodge,默认docker0docker run -d -P --name tomcat01 --net bridge tomcat# docker0的特点: 默认的,域名是不能访问的, --link可以打通连接# 自定义网络# --driver bridgedocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55$ docker network lsNETWORK ID NAME DRIVER SCOPE86c70406cec4 bridge bridge locale2cd35c81ffb host host local87d0f163b3a0 mynet bridge localc6fe6b78ab62 none null local 自己的网络创建好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105$ docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123;&#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]$ docker run -d -P --name tomcat-net-01 --net mynet tomcatf8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8$ docker run -d -P --name tomcat-net-02 --net mynet tomcat84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c$ docker network inspect mynet[ &#123; \"Name\": \"mynet\", \"Id\": \"87d0f163b3a0c857d281bf4e97675d03555486c530969d1cb04950f203133b55\", \"Created\": \"2020-07-08T01:56:39.0611734Z\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123; \"84b8b3a4a45c579eb479dfa036bc6e88f2c4ea5a0e8edd0c8f225bddebb2747c\": &#123; \"Name\": \"tomcat-net-02\", \"EndpointID\": \"889a15d10cf311193a18033af3a75eefa6a074291e84aab65e9d88f4b9889bf2\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" &#125;, \"f8acd6bd8a21c27ca293d4c2d150448299192bd1f58b41d273d61d24cfe7d9a8\": &#123; \"Name\": \"tomcat-net-01\", \"EndpointID\": \"810c98a4ee532167410f1bc28acbc1d3aac11390e7c5a0c0864c20832bf06fb6\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" &#125; &#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]# 再次测试ping连接$ docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.056 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.156 ms64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.086 ms64 bytes from 192.168.0.3: icmp_seq=4 ttl=64 time=0.037 ms^C--- 192.168.0.3 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 162msrtt min/avg/max/mdev = 0.037/0.083/0.156/0.046 ms# 现在不使用--link也可以ping容器名字$ docker exec -it tomcat-net-02 ping 192.168.0.2PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.039 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.066 ms^C--- 192.168.0.2 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 47msrtt min/avg/max/mdev = 0.039/0.052/0.066/0.015 ms 自定义网络docker都帮我们维护好了对应关系，推荐平时这样使用网络！ 好处: 不同的集群使用不同的集群,保证集群之间是安全和健康的 网络连通 1234#测试打通 tomcat01到tomcat-net-01$ docker network connect mynet tomcat01# 连通之后就是将 tomcat01 放到了mynet网络下# 一个容器两个ip 阿里云: 公网ip 私网ip 12345678910111213# 01 连通ok$ docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.087 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.065 ms^C--- tomcat-net-01 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 71msrtt min/avg/max/mdev = 0.065/0.076/0.087/0.011 ms# 02 依旧是连不通的$ docker exec -it tomcat02 ping tomcat-net-01ping: tomcat-net-01: Name or service not known 结论：要跨网络操作别人，就需要使用 docker network connect 连通","categories":[{"name":"技术","slug":"技术","permalink":"https://github.com/Kaviilee/blog.git/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/Kaviilee/blog.git/tags/docker/"}],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}},{"title":"js获取视口和文档高度","slug":"js获取视口和文档高度","date":"2019-09-07T09:25:18.000Z","updated":"2020-08-03T13:04:39.078Z","comments":true,"path":"2019/09/07/js获取视口和文档高度/","link":"","permalink":"https://github.com/Kaviilee/blog.git/2019/09/07/js%E8%8E%B7%E5%8F%96%E8%A7%86%E5%8F%A3%E5%92%8C%E6%96%87%E6%A1%A3%E9%AB%98%E5%BA%A6/","excerpt":"js获取视口和文档高度","text":"js获取视口和文档高度 js获取视口和文档高度 项目 内容 clientHeight content area + padding offsetHeight border + content area + padding scrollHeight 没有滚动条（内容展开时）的高度 body和html分别表示document.body和document.documentElement html.clientHeight 返回视口高度html.offsetHeight 返回元素的高度，在没有给元素设置height时，可以理解为文档高度。ie6-8返回视口高度html.scrollHeight 总是返回文档高度。在firefox，opera，ie8中，返回文档高度和视口高度中较大的那个body.clientHeight和body.offsetHeight 返回元素的高度（近似于文档高度），如果设置height，则返回设定的值（ie6仍然返回内元素的总高度）。body.scrollHeight 总是返回文档高度。在webkit中，返回文档高度和视口高度中较大的那个。 总之，获取视口高度用html.clientHeight,IE6-8还可以用html.offsetHeight。获取文档高度可以用html.scrollHeight或body.scrollHeight。 另外，​​现代浏览器中还有一个属性window.innerHeight可以用来获取视口高度，IE9+才开始支持。得到的高度有时候会多十几个像素，innerHeight把滚动条的高度也计算在内。 1234567// 获取视口高度let viewportH = window.innerHeight || document.documentElement.clientHeight;// 获取文档高度let docH = document.body.scrollHeight;// 或者let docH = document.documentElement.scrollHeight","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://github.com/Kaviilee/blog.git/categories/javascript/"}],"tags":[],"author":{"name":"Kaviilee","avatar":"https://cdn.jsdelivr.net/gh/Kaviilee/cdn@1.1/blog/images/custom/papalymo.jpg"}}],"categories":[{"name":"技术","slug":"技术","permalink":"https://github.com/Kaviilee/blog.git/categories/%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"javascript","permalink":"https://github.com/Kaviilee/blog.git/categories/javascript/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/Kaviilee/blog.git/tags/docker/"}]}